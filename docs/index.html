<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Commander Box League - Booster Simulator</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <div id="app">
        <header>
            <h1>Commander Box League</h1>
            <div class="cbl-description" style="margin-bottom: 1em; font-size: 1em;">
                <small>
                    This tool is for simulating virtual <a href="https://wpn.wizards.com/en/event/edge-of-eternities-commander-box-league" target="_blank" rel="noopener noreferrer">Commander Box League</a> deck building.
                </small>
            </div>
        </header>

        <main>
            <div id="loading-overlay" class="loading-overlay" style="display: none;">
                <div class="loading-content">
                    <div class="loading-spinner"></div>
                    <p>Loading card data...</p>
                </div>
            </div>

            <section id="controls">
                <div class="set-selection">
                    <label for="set-select">Select Set:</label>
                    <select id="set-select" disabled>
                    </select>
                </div>

                <div class="booster-type">
                    <label for="booster-type">Booster Type:</label>
                    <select id="booster-type" disabled>
                    </select>
                </div>

                <div class="box-size">
                    <label for="box-size">Box Size:</label>
                    <input type="number" id="box-size" min="1" step="1" placeholder="Enter box size" disabled>
                </div>

                <button id="open-booster" class="primary-button" disabled>Loading...</button>
            </section>

            <section id="results">
                <div id="card-pool-and-deck-wrapper">
                    <div id="card-pool-section">
                        <h3>Card Pool</h3>
                        <div class="card-pool-controls">
                            <div class="filter-section">
                                <div class="filter-section-header">
                                    <div class="filter-header-left">
                                        <button id="toggle-filters-btn" class="toggle-filters-btn">
                                            <span class="toggle-icon">‚ñ∂</span>
                                        </button>
                                        <h4>Filters</h4>
                                        <span id="active-filters-indicator" class="active-filters-indicator" style="display: none;">
                                            <span class="indicator-dot"></span>
                                            Active
                                        </span>
                                    </div>
                                    <button id="clear-filters-btn" class="clear-filters-btn">
                                        <span class="clear-icon">√ó</span>
                                        Clear All
                                    </button>
                                </div>

                                <div class="filter-grid collapsed" id="filter-grid">
                                    <div class="filter-group">
                                        <label for="search-input" class="filter-label">
                                            <span class="filter-icon">üîç</span>
                                            Search
                                        </label>
                                        <input type="text" id="search-input" placeholder="Search cards by name..." class="search-input">
                                    </div>

                                    <div class="filter-group">
                                        <label for="sort-select" class="filter-label">
                                            <span class="filter-icon">‚ÜïÔ∏è</span>
                                            Sort By
                                        </label>
                                        <select id="sort-select" class="filter-select">
                                            <option value="name">Name (A-Z)</option>
                                            <option value="name-desc">Name (Z-A)</option>
                                            <option value="rarity">Rarity</option>
                                            <option value="type">Type</option>
                                            <option value="cmc">Mana Cost</option>
                                        </select>
                                    </div>

                                    <div class="filter-group">
                                        <label for="filter-rarity" class="filter-label">
                                            <span class="filter-icon">‚≠ê</span>
                                            Rarity
                                        </label>
                                        <select id="filter-rarity" class="filter-select">
                                            <option value="all">All Rarities</option>
                                            <option value="mythic">Mythic Rare</option>
                                            <option value="rare">Rare</option>
                                            <option value="uncommon">Uncommon</option>
                                            <option value="common">Common</option>
                                        </select>
                                    </div>

                                    <div class="filter-group">
                                        <label for="filter-type" class="filter-label">
                                            <span class="filter-icon">üè∑Ô∏è</span>
                                            Type
                                        </label>
                                        <select id="filter-type" class="filter-select">
                                            <option value="all">All Types</option>
                                            <option value="creature">Creature</option>
                                            <option value="instant">Instant</option>
                                            <option value="sorcery">Sorcery</option>
                                            <option value="enchantment">Enchantment</option>
                                            <option value="artifact">Artifact</option>
                                            <option value="planeswalker">Planeswalker</option>
                                            <option value="land">Land</option>
                                        </select>
                                    </div>

                                    <div class="filter-group color-filter-group">
                                        <label class="filter-label">
                                            <span class="filter-icon">üé®</span>
                                            Colors
                                        </label>
                                        <div class="color-filter-options">
                                            <label class="color-checkbox">
                                                <input type="checkbox" id="filter-color-w" value="W">
                                                <span class="color-symbol" id="color-symbol-w"></span>
                                            </label>
                                            <label class="color-checkbox">
                                                <input type="checkbox" id="filter-color-u" value="U">
                                                <span class="color-symbol" id="color-symbol-u"></span>
                                            </label>
                                            <label class="color-checkbox">
                                                <input type="checkbox" id="filter-color-b" value="B">
                                                <span class="color-symbol" id="color-symbol-b"></span>
                                            </label>
                                            <label class="color-checkbox">
                                                <input type="checkbox" id="filter-color-r" value="R">
                                                <span class="color-symbol" id="color-symbol-r"></span>
                                            </label>
                                            <label class="color-checkbox">
                                                <input type="checkbox" id="filter-color-g" value="G">
                                                <span class="color-symbol" id="color-symbol-g"></span>
                                            </label>
                                            <label class="color-checkbox">
                                                <input type="checkbox" id="filter-color-c" value="C">
                                                <span class="color-symbol" id="color-symbol-c"></span>
                                            </label>
                                        </div>
                                    </div>

                                    <div class="filter-group commander-filter-group">
                                        <label for="valid-commanders-only" class="filter-label commander-label">
                                            <span class="filter-icon">üëë</span>
                                            <span class="commander-text">Commanders Only</span>
                                            <input type="checkbox" id="valid-commanders-only" class="commander-checkbox">
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div id="card-pool-scroll" class="scroll-section">
                            <div id="card-pool">
                                <ul class="card-pool-list" id="card-pool-list-all"></ul>
                            </div>
                        </div>
                        <div id="card-pool-summary" class="card-pool-summary">
                            <span id="card-count-display">0 cards</span>
                        </div>
                    </div>
                    <div id="commander-deck-section">
                        <h3 style="margin: 0 0 0.5em 0;">Deck</h3>
                        <div class="deck-controls-bar">
                            <div class="deck-controls-buttons">
                                <button id="clear-deck-btn" class="secondary-button small">Clear Deck</button>
                                <button id="export-deck-btn" class="secondary-button small">Export to Moxfield</button>
                            </div>
                        </div>
                        <div id="commander-deck-scroll" class="scroll-section">
                            <div id="commander-deck" class="card-pool-group">
                                <details class="deck-panel" open>
                                    <summary>Commander</summary>
                                    <div class="card-pool-group">
                                        <ul class="card-pool-list" id="commander-deck-commander"></ul>
                                    </div>
                                </details>
                                <details class="deck-panel" open>
                                    <summary>Deck</summary>
                                    <div class="card-pool-group">
                                        <ul class="card-pool-list" id="commander-deck-cards"></ul>
                                    </div>
                                </details>
                                <details class="deck-panel" open>
                                    <summary>Basic Lands</summary>
                                    <div class="card-pool-group">
                                        <ul class="card-pool-list" id="commander-deck-basic-lands"></ul>
                                    </div>
                                </details>
                            </div>
                        </div>
                        <div id="deck-summary" class="deck-summary">
                            <span id="deck-count-display">0 / 60</span>
                        </div>
                    </div>
                </div>

                <div id="boosters-section">
                    <div class="boosters-header">
                        <h4>Boosters</h4>
                        <button id="toggle-boosters-btn" class="toggle-boosters-btn" title="Expand boosters">
                            <span class="toggle-boosters-icon">‚ñ∂</span>
                        </button>
                    </div>
                    <div id="booster-display" class="boosters-content collapsed"></div>
                </div>
            </section>
        </main>
    </div>

    <!-- Export Overlay -->
    <div id="export-overlay" class="overlay" style="display: none;">
        <div class="overlay-content">
            <div class="overlay-header">
                <h3>Export Deck to Moxfield</h3>
                <button id="close-export-overlay" class="close-btn">&times;</button>
            </div>
            <div class="overlay-body">
                <p>Copy the deck list below and paste it into Moxfield's import function:</p>
                <textarea id="deck-export-text" readonly></textarea>
            </div>
            <div class="overlay-footer">
                <button id="copy-deck-btn" class="primary-button">Copy to Clipboard</button>
                <button id="cancel-export-btn" class="secondary-button">Close</button>
            </div>
        </div>
    </div>

    <!-- Card View Overlay -->
    <div id="card-view-overlay" class="overlay" style="display: none;">
        <div class="overlay-content card-view-content">
            <div class="overlay-header">
                <h3 id="card-view-title">Card Details</h3>
                <button id="close-card-view-overlay" class="close-btn">&times;</button>
            </div>
            <div class="overlay-body">
                <div class="card-view-layout">
                    <div class="card-view-left">
                        <div id="card-view-image-container">
                            <img id="card-view-image" src="" alt="">
                        </div>
                    </div>
                    <div class="card-view-right">
                        <div id="card-view-details">
                            <p id="card-view-name"></p>
                            <p id="card-view-type"></p>
                            <p id="card-view-text"></p>
                            <div class="card-view-links">
                                <a id="card-view-scryfall-link" href="#" target="_blank" rel="noopener noreferrer" class="scryfall-link">
                                    <img src="https://avatars.githubusercontent.com/u/22605579?s=200&v=4" alt="Scryfall" class="scryfall-icon">
                                    View on Scryfall
                                </a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer with GitHub link and Scryfall reference -->
    <footer>
        <div class="footer-content">
            <div class="footer-left">
                <span>Data provided by</span>
                <a href="https://scryfall.com" target="_blank" rel="noopener noreferrer">Scryfall</a>
            </div>
            <a href="https://github.com/muz/commander_box_league" class="footer-github-link" target="_blank" rel="noopener noreferrer">
                <svg class="github-icon" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                </svg>
                View on GitHub
            </a>
        </div>
    </footer>

    <script src="js/scryfall-api.js"></script>
    <script>
        // Global variables
        let cardSets = [];
        let selectedSet = null;
        let setData = null;
        let bonusSheetData = null;
        let setMetadata = null; // Global variable to store set metadata
        let scryfallAPI = new ScryfallAPI();
        let symbologyData = null; // Global variable to store symbology data
        // Commander deck state
        let commanderDeck = {
            commander: null, // { name, ... }
            cards: [], // for future deck-building
            basicLands: {
                Plains: 0,
                Island: 0,
                Swamp: 0,
                Mountain: 0,
                Forest: 0
            }
        };
        // Add at the top-level script scope:
        let cardPool = {
            mythic: {},
            rare: {},
            uncommon: {},
            common: {}
        };
        let cardDataMap = {};

        // Filter and sort state
        let filterState = {
            sortBy: 'name',
            rarityFilter: 'all',
            typeFilter: 'all',
            searchQuery: '',
            validCommandersOnly: false,
            colorFilter: []
        };

        // Helper: get symbology data
        function getSymbologyData() {
            return symbologyData || scryfallAPI.getSymbology();
        }

        // Helper: get SVG URI for a mana symbol
        function getManaSymbolSvgUri(symbol) {
            const symbology = getSymbologyData();
            if (!symbology || !symbology.data) return null;

            const symbolData = symbology.data.find(s => s.symbol === symbol);
            return symbolData ? symbolData.svg_uri : null;
        }

        // Helper: create mana symbol HTML with configurable size
        function createManaSymbolHtml(symbol, size = 16, fallbackText = null) {
            const svgUri = getManaSymbolSvgUri(symbol);

            if (svgUri) {
                return `<img src="${svgUri}" alt="${symbol}" width="${size}" height="${size}" style="display: inline-block; vertical-align: middle;">`;
            } else {
                // Fallback to text if SVG is not available
                return fallbackText || symbol;
            }
        }

        // Helper: replace symbols in text with their SVG equivalents
        function replaceSymbolsInText(text) {
            if (!text) return '';

            // Replace symbols wrapped in curly braces with their SVG equivalents
            return text.replace(/\{([^}]+)\}/g, (match, symbol) => {
                const symbolHtml = createManaSymbolHtml(`{${symbol}}`, 16);
                if (symbolHtml !== `{${symbol}}`) {
                    return symbolHtml;
                }
                return match; // Return original if symbol not found
            });
        }

        // Helper: check if a card is a Legendary Creature
        function isLegendaryCreature(card) {
            return card && card.typeLine && card.typeLine.includes('Legendary Creature');
        }

        // Helper: get color identity for sorting (WUBRG order)
        function getColorIdentity(card) {
            if (!card || !card.colorIdentity || card.colorIdentity.length === 0) {
                return 'C'; // Colorless
            }

            // WUBRG order: White, Blue, Black, Red, Green
            const colorOrder = ['W', 'U', 'B', 'R', 'G'];

            // Sort the card's colors according to WUBRG order
            const sortedColors = card.colorIdentity
                .filter(color => colorOrder.includes(color))
                .sort((a, b) => colorOrder.indexOf(a) - colorOrder.indexOf(b));

            return sortedColors.join('');
        }

                // Helper: get color identity sort value for WUBRG ordering
        function getColorIdentitySortValue(card) {
            const colorIdentity = getColorIdentity(card);

            if (colorIdentity === 'C') {
                return 999; // Colorless cards come last
            }

            // For colored cards, create a sort value based on WUBRG order
            // Single colors get lower values, multi-colors get higher values
            const colorOrder = ['W', 'U', 'B', 'R', 'G'];
            let sortValue = 0;

            for (let i = 0; i < colorIdentity.length; i++) {
                const color = colorIdentity[i];
                const colorIndex = colorOrder.indexOf(color);
                sortValue += colorIndex * Math.pow(10, colorIdentity.length - 1 - i);
            }

            // Add a base value based on number of colors to ensure single colors come before multi-colors
            sortValue += (colorIdentity.length - 1) * 1000;

            return sortValue;
        }

        // Helper: populate color filter symbols with Scryfall mana symbols
        function populateColorFilterSymbols() {
            const colorSymbols = {
                'W': '{W}',
                'U': '{U}',
                'B': '{B}',
                'R': '{R}',
                'G': '{G}',
                'C': '{C}'
            };

            Object.keys(colorSymbols).forEach(color => {
                const symbolElement = document.getElementById(`color-symbol-${color.toLowerCase()}`);
                if (!symbolElement) return;

                const symbolText = colorSymbols[color];
                symbolElement.innerHTML = createManaSymbolHtml(symbolText, 20);
            });
        }

        // Update card pool title with set name and image
        function updateCardPoolTitle() {
            const cardPoolSection = document.getElementById('card-pool-section');
            const titleElement = cardPoolSection.querySelector('h3');

            if (setMetadata && selectedSet) {
                // Create the new title with set image and name
                let titleHtml = '';

                // Add set icon if available
                if (setMetadata.icon_svg_uri) {
                    titleHtml += `<img src="${setMetadata.icon_svg_uri}" alt="${setMetadata.name}" style="width: 24px; height: 24px; margin-right: 8px; vertical-align: middle;">`;
                }

                // Add set name
                titleHtml += `${setMetadata.name} Card Pool`;

                titleElement.innerHTML = titleHtml;
            } else {
                // Fallback to default title
                titleElement.textContent = 'Card Pool';
            }
        }

        // Render the deck cards in the deck UI
        function renderDeckCards() {
            const deckList = document.getElementById('commander-deck-cards');
            deckList.innerHTML = '';
            // Count cards in deck by name
            const deckCounts = {};
            commanderDeck.cards.forEach(card => {
                deckCounts[card.name] = (deckCounts[card.name] || 0) + 1;
            });
            Object.keys(deckCounts).sort().forEach(name => {
                const count = deckCounts[name];
                const card = commanderDeck.cards.find(c => c.name === name);
                const li = document.createElement('li');
                let cardImageHtml = '';
                if (card.imageUris) {
                    if (card.imageUris.normal) {
                        cardImageHtml = `<div class=\"card-image-container\"><img src=\"${card.imageUris.normal}\" alt=\"${card.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                    } else if (card.imageUris.small) {
                        cardImageHtml = `<div class=\"card-image-container\"><img src=\"${card.imageUris.small}\" alt=\"${card.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                    }
                }
                if (!cardImageHtml) {
                    cardImageHtml = `<div class='card-fallback-text'><strong>${card.name}</strong><br><span>${card.typeLine||''}</span></div>`;
                }
                let countBadge = '';
                if (count >= 2) {
                    countBadge = `<span class=\"card-count-badge\">${count}</span>`;
                }
                li.innerHTML = `
                    <div class=\"card-pool-item\">
                        <div class=\"card-image-action-container\" data-card-name=\"${card.name.replace(/\"/g, '&quot;')}\">
                            ${cardImageHtml}
                            ${countBadge}
                            <div class=\"card-action-icons\"><button class=\"icon-btn remove-from-deck-btn\" data-card-name=\"${card.name.replace(/\"/g, '&quot;')}\" aria-label=\"Remove from Deck\"><span class=\"icon minus\"></span></button></div>
                        </div>
                    </div>
                `;
                deckList.appendChild(li);
            });
            // Remove event listeners
            document.querySelectorAll('.remove-from-deck-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    const cardName = this.getAttribute('data-card-name');
                    // Remove one copy from deck
                    const idx = commanderDeck.cards.findIndex(c => c.name === cardName);
                    if (idx !== -1) {
                        commanderDeck.cards.splice(idx, 1);
                        renderCommanderDeck();
                        renderDeckCards();
                        renderCardPool();
                    }
                });
            });
        }

        // Update renderCommanderDeck to also render deck cards
        function renderCommanderDeck() {
            // Commander
            const commanderList = document.getElementById('commander-deck-commander');
            commanderList.innerHTML = '';
            if (commanderDeck.commander) {
                const card = commanderDeck.commander;
                const li = document.createElement('li');
                let cardImageHtml = '';
                if (card.imageUris) {
                    if (card.imageUris.normal) {
                        cardImageHtml = `<div class=\"card-image-container\"><img src=\"${card.imageUris.normal}\" alt=\"${card.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                    } else if (card.imageUris.small) {
                        cardImageHtml = `<div class=\"card-image-container\"><img src=\"${card.imageUris.small}\" alt=\"${card.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                    }
                }
                if (!cardImageHtml) {
                    cardImageHtml = `<div class='card-fallback-text'><strong>${card.name}</strong><br><span>${card.typeLine||''}</span></div>`;
                }
                li.innerHTML = `
                    <div class=\"card-pool-item\">
                        <div class=\"card-image-action-container\" data-card-name=\"${card.name}\">
                            ${cardImageHtml}
                            <div class=\"card-action-icons\">
                                <button class=\"icon-btn unset-commander-btn\" aria-label=\"Remove as Commander\"><span class=\"icon minus\"></span></button>
                            </div>
                        </div>
                        <div class=\"card-pool-name\">${card.name}</div>
                    </div>
                `;
                commanderList.appendChild(li);
            }
            // Deck cards
            renderDeckCards();
            // Basic lands
            renderBasicLands();
            // Stats
            updateCommanderDeckStats();
            // Unset commander event
            const unsetBtn = document.querySelector('.unset-commander-btn');
            if (unsetBtn) {
                unsetBtn.addEventListener('click', function() {
                    commanderDeck.commander = null;
                    renderCommanderDeck();
                    renderCardPool();
                });
            }
        }

        // Update the stats pane
        function updateCommanderDeckStats() {
            const deckCountDisplay = document.getElementById('deck-count-display');
            const deckSummary = document.getElementById('deck-summary');
            const commanderCount = commanderDeck.commander ? 1 : 0;
            const deckCount = commanderDeck.cards.length;
            const basicLandsCount = Object.values(commanderDeck.basicLands).reduce((sum, count) => sum + count, 0);
            const totalCount = commanderCount + deckCount + basicLandsCount;

            // Always show "X / 60 Cards" format
            deckCountDisplay.textContent = `${totalCount} / 60 Cards`;

            // Change background to tasteful red if over 60
            if (totalCount > 60) {
                deckSummary.style.background = '#fef2f2';
                deckSummary.style.borderColor = '#fecaca';
                deckSummary.style.color = '#dc2626';
            } else {
                deckSummary.style.background = '#f8f9fa';
                deckSummary.style.borderColor = '#e9ecef';
                deckSummary.style.color = '#6c757d';
            }
        }

                // Clear the entire deck and return all cards to the pool
        function clearDeck() {
            if (commanderDeck.cards.length === 0 && !commanderDeck.commander &&
                Object.values(commanderDeck.basicLands).every(count => count === 0)) {
                return; // Nothing to clear
            }

            // Clear commander
            commanderDeck.commander = null;

            // Clear deck cards (they're already in the pool, so no need to add them back)
            commanderDeck.cards = [];

            // Clear basic lands
            commanderDeck.basicLands = {
                Plains: 0,
                Island: 0,
                Swamp: 0,
                Mountain: 0,
                Forest: 0
            };

            // Re-render everything
            renderCommanderDeck();
            renderCardPool();
            updateCardPoolTitle(); // Update title to reflect current set
        }

                // Generate deck list in Moxfield format
        function generateMoxfieldDeckList() {
            let deckList = '';

            // Add commander first (if exists)
            if (commanderDeck.commander) {
                const setCode = commanderDeck.commander.setCode || '';
                const collectorNumber = commanderDeck.commander.collectorNumber || '';
                deckList += `1 ${commanderDeck.commander.name}${setCode ? ` (${setCode}) ${collectorNumber}` : ''}\n`;
            }

            // Add deck cards
            const deckCounts = {};
            const cardDetails = {};
            commanderDeck.cards.forEach(card => {
                if (!deckCounts[card.name]) {
                    deckCounts[card.name] = 0;
                    cardDetails[card.name] = card;
                }
                deckCounts[card.name]++;
            });

            // Sort cards alphabetically
            Object.keys(deckCounts).sort().forEach(cardName => {
                const count = deckCounts[cardName];
                const card = cardDetails[cardName];
                const setCode = card.setCode || '';
                const collectorNumber = card.collectorNumber || '';
                deckList += `${count} ${cardName}${setCode ? ` (${setCode}) ${collectorNumber}` : ''}\n`;
            });

            // Add basic lands (no set code needed for basic lands)
            Object.keys(commanderDeck.basicLands).forEach(landType => {
                const count = commanderDeck.basicLands[landType];
                if (count > 0) {
                    deckList += `${count} ${landType}\n`;
                }
            });

            return deckList.trim();
        }

        // Show export overlay
        function showExportOverlay() {
            const deckList = generateMoxfieldDeckList();
            if (!deckList) {
                alert('Your deck is empty. Add some cards before exporting.');
                return;
            }

            document.getElementById('deck-export-text').value = deckList;
            document.getElementById('export-overlay').style.display = 'flex';
        }

        // Hide export overlay
        function hideExportOverlay() {
            document.getElementById('export-overlay').style.display = 'none';
        }

        // Copy deck list to clipboard
        async function copyDeckToClipboard() {
            try {
                const deckText = document.getElementById('deck-export-text').value;
                await navigator.clipboard.writeText(deckText);

                // Show success feedback
                const copyBtn = document.getElementById('copy-deck-btn');
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'Copied!';
                copyBtn.style.background = '#22c55e';

                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = '';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy to clipboard:', err);
                alert('Failed to copy to clipboard. Please select and copy the text manually.');
            }
        }

        // Show card view overlay
        function showCardViewOverlay(cardName) {
            // Find the card data
            let found = null;
            for (const rarity in cardPool) {
                if (cardPool[rarity][cardName]) {
                    found = cardDataMap[cardName];
                    break;
                }
            }

            // Also check in deck cards
            if (!found) {
                found = commanderDeck.cards.find(card => card.name === cardName);
            }

            // Also check commander
            if (!found && commanderDeck.commander && commanderDeck.commander.name === cardName) {
                found = commanderDeck.commander;
            }

            if (!found) {
                console.error('Card not found:', cardName);
                return;
            }

            // Update overlay content
            document.getElementById('card-view-title').textContent = found.name;
            document.getElementById('card-view-name').textContent = found.name;
            document.getElementById('card-view-type').textContent = found.typeLine || '';
            document.getElementById('card-view-text').innerHTML = replaceSymbolsInText(found.oracleText || '');

            // Set card image
            const cardImage = document.getElementById('card-view-image');
            if (found.imageUris && found.imageUris.normal) {
                cardImage.src = found.imageUris.normal;
                cardImage.alt = found.name;
                cardImage.style.display = 'block';
            } else if (found.imageUris && found.imageUris.small) {
                cardImage.src = found.imageUris.small;
                cardImage.alt = found.name;
                cardImage.style.display = 'block';
            } else {
                cardImage.style.display = 'none';
            }

            // Set Scryfall link
            const scryfallLink = document.getElementById('card-view-scryfall-link');
            scryfallLink.href = found.scryfall_uri || `https://scryfall.com/search?q=!"${encodeURIComponent(found.name)}"`;

            // Show overlay
            document.getElementById('card-view-overlay').style.display = 'flex';
        }

        // Hide card view overlay
        function hideCardViewOverlay() {
            document.getElementById('card-view-overlay').style.display = 'none';
        }



        // Populate set dropdown
        function populateSetDropdown() {
            const setSelect = document.getElementById('set-select');

            // Add sets from JSON
            cardSets.forEach(set => {
                // Only include sets where enabled is not declared or is not false
                if (set.enabled === false) return;
                const option = document.createElement('option');
                option.value = set.code;
                option.textContent = set.name;
                setSelect.appendChild(option);
            });
        }

        // Fetch set data and bonus sheet data
        async function fetchSetData(setCode) {
            const openBoxBtn = document.getElementById('open-booster');
            try {
                openBoxBtn.disabled = true;
                openBoxBtn.textContent = 'Loading...';

                // Fetch main set data from Scryfall API
                setData = await scryfallAPI.fetchSetData(setCode);
                console.log(`Fetched set data for ${setCode}:`, setData);

                // Fetch bonus sheet data if it exists
                if (selectedSet.bonusSheet) {
                    bonusSheetData = await scryfallAPI.fetchSetData(selectedSet.bonusSheet.code);
                    console.log(`Fetched bonus sheet data for ${selectedSet.bonusSheet.code}:`, bonusSheetData);
                } else {
                    bonusSheetData = null;
                    console.log('No bonus sheet for this set');
                }

                enableSetControls();

            } catch (error) {
                console.error('Error fetching set data:', error);
                setData = null;
                bonusSheetData = null;
                enableSetControls();
                alert(`Error fetching data for set ${setCode}: ${error.message}`);
            }
        }



        // Loading state management
        function setLoadingState(isLoading) {
            const loadingOverlay = document.getElementById('loading-overlay');
            const setSelect = document.getElementById('set-select');
            const boosterTypeSelect = document.getElementById('booster-type');
            const boxSizeInput = document.getElementById('box-size');
            const openBoosterBtn = document.getElementById('open-booster');

            if (isLoading) {
                loadingOverlay.style.display = 'flex';
                setSelect.disabled = true;
                boosterTypeSelect.disabled = true;
                boxSizeInput.disabled = true;
                openBoosterBtn.disabled = true;
                openBoosterBtn.textContent = 'Loading...';
            } else {
                loadingOverlay.style.display = 'none';
                setSelect.disabled = false;
                // Enable box size input when loading is complete
                boxSizeInput.disabled = false;
                openBoosterBtn.textContent = 'Open Box!';
            }
        }

        // Enable controls after set data is loaded
        function enableSetControls() {
            const boosterTypeSelect = document.getElementById('booster-type');
            const boxSizeInput = document.getElementById('box-size');
            const openBoosterBtn = document.getElementById('open-booster');

            boosterTypeSelect.disabled = false;
            boxSizeInput.disabled = false;
            openBoosterBtn.disabled = false;
            openBoosterBtn.textContent = 'Open Box!';
        }

        // Update booster types based on selected set
        async function updateBoosterTypes() {
            const boosterTypeSelect = document.getElementById('booster-type');
            const boxSizeInput = document.getElementById('box-size');
            const setSelect = document.getElementById('set-select');

            // Clear existing options
            boosterTypeSelect.disabled = true;

            if (setSelect.value) {
                selectedSet = cardSets.find(set => set.code === setSelect.value);

                // Fetch set metadata from Scryfall API
                try {
                    setMetadata = await scryfallAPI.fetchSetMetadata(selectedSet.code);
                    console.log('Set metadata:', setMetadata);

                    // Update the card pool title with set information
                    updateCardPoolTitle();

                } catch (error) {
                    console.warn('Failed to fetch set metadata:', error);
                    setMetadata = null;
                    // Continue with the rest of the function even if metadata fetch fails
                }

                if (selectedSet && selectedSet.boosterTypes) {
                    let firstType = null;
                    Object.keys(selectedSet.boosterTypes).forEach((boosterType, idx) => {
                        const boosterConfig = selectedSet.boosterTypes[boosterType];
                        const option = document.createElement('option');
                        option.value = boosterType.toLowerCase();
                        option.textContent = boosterType;
                        option.dataset.boxSize = boosterConfig.boxSize;
                        boosterTypeSelect.appendChild(option);
                        if (firstType === null) firstType = boosterType.toLowerCase();
                    });
                    if (firstType) {
                        boosterTypeSelect.value = firstType;
                        boosterTypeSelect.disabled = false;
                        boosterTypeSelect.dispatchEvent(new Event('change'));
                    }
                }

                // Fetch set data and bonus sheet data
                await fetchSetData(selectedSet.code);
            } else {
                selectedSet = null;
                setData = null;
                bonusSheetData = null;
            }
        }

        // Update box size based on selected booster type
        function updateBoxSize() {
            const boosterTypeSelect = document.getElementById('booster-type');
            const boxSizeInput = document.getElementById('box-size');

            // Clear the input field
            boxSizeInput.value = '';

            if (boosterTypeSelect.value && selectedSet) {
                const boosterType = boosterTypeSelect.value;
                const boosterConfig = selectedSet.boosterTypes[boosterType.charAt(0).toUpperCase() + boosterType.slice(1)];

                if (boosterConfig && boosterConfig.boxSize) {
                    // Set the default box size as the input value
                    boxSizeInput.value = boosterConfig.boxSize;
                }
            }
        }

        // Move renderCardPool to top-level scope
        function renderCardPool() {
            // Count cards in deck by name
            const deckCounts = {};
            commanderDeck.cards.forEach(card => {
                deckCounts[card.name] = (deckCounts[card.name] || 0) + 1;
            });
            // Exclude commander from add-to-deck
            const commanderName = commanderDeck.commander ? commanderDeck.commander.name : null;

            // Get the single card pool list
            const ul = document.getElementById('card-pool-list-all');
            ul.innerHTML = '';

            // Collect all cards from all rarities into a single array
            const allCards = [];
            Object.keys(cardPool).forEach(rarity => {
                const cards = cardPool[rarity];
                const sortedNames = Object.keys(cards).sort();

                sortedNames.forEach(name => {
                    const count = cards[name];
                    const cardData = cardDataMap[name];
                    if (!cardData) return;

                    const available = count - (deckCounts[cardData.name] || 0);
                    if (available <= 0) return; // Skip rendering this card if none are available
                    // Skip rendering if this card is the commander
                    if (commanderName && cardData.name === commanderName) return;

                    allCards.push({ name, count, cardData, available, rarity });
                });
            });

            // Apply filters
            let filteredCards = allCards.filter(card => {
                // Rarity filter
                if (filterState.rarityFilter !== 'all' && card.rarity !== filterState.rarityFilter) {
                    return false;
                }

                // Type filter
                if (filterState.typeFilter !== 'all') {
                    const typeLine = card.cardData.typeLine || '';
                    if (filterState.typeFilter === 'creature' && !typeLine.includes('Creature')) return false;
                    if (filterState.typeFilter === 'instant' && !typeLine.includes('Instant')) return false;
                    if (filterState.typeFilter === 'sorcery' && !typeLine.includes('Sorcery')) return false;
                    if (filterState.typeFilter === 'enchantment' && !typeLine.includes('Enchantment')) return false;
                    if (filterState.typeFilter === 'artifact' && !typeLine.includes('Artifact')) return false;
                    if (filterState.typeFilter === 'planeswalker' && !typeLine.includes('Planeswalker')) return false;
                    if (filterState.typeFilter === 'land' && !typeLine.includes('Land')) return false;
                }

                // Color filter
                if (filterState.colorFilter.length > 0) {
                    const cardColors = card.cardData.colorIdentity || [];
                    const isColorless = cardColors.length === 0;

                    // Check if card matches any of the selected colors
                    let matches = false;

                    for (const selectedColor of filterState.colorFilter) {
                        if (selectedColor === 'C' && isColorless) {
                            matches = true;
                            break;
                        } else if (cardColors.includes(selectedColor)) {
                            matches = true;
                            break;
                        }
                    }

                    if (!matches) return false;
                }

                // Search filter
                if (filterState.searchQuery && !card.name.toLowerCase().includes(filterState.searchQuery.toLowerCase())) {
                    return false;
                }

                // Commander filter
                if (filterState.validCommandersOnly && !isLegendaryCreature(card.cardData)) {
                    return false;
                }

                return true;
            });

            // Apply sorting
            filteredCards.sort((a, b) => {
                switch (filterState.sortBy) {
                    case 'name':
                        return a.name.localeCompare(b.name);
                    case 'name-desc':
                        return b.name.localeCompare(a.name);
                    case 'rarity':
                        const rarityOrder = { mythic: 0, rare: 1, uncommon: 2, common: 3 };
                        const rarityDiff = rarityOrder[a.rarity] - rarityOrder[b.rarity];
                        return rarityDiff !== 0 ? rarityDiff : a.name.localeCompare(b.name);
                    case 'type':
                        const aType = a.cardData.typeLine || '';
                        const bType = b.cardData.typeLine || '';
                        const typeDiff = aType.localeCompare(bType);
                        return typeDiff !== 0 ? typeDiff : a.name.localeCompare(b.name);
                    case 'cmc':
                        const aCmc = a.cardData.cmc || 0;
                        const bCmc = b.cardData.cmc || 0;
                        const cmcDiff = aCmc - bCmc;
                        if (cmcDiff !== 0) {
                            return cmcDiff;
                        }
                        // If CMC is the same, sort by color identity (WUBRG order)
                        const aColorSort = getColorIdentitySortValue(a.cardData);
                        const bColorSort = getColorIdentitySortValue(b.cardData);
                        const colorDiff = aColorSort - bColorSort;
                        return colorDiff !== 0 ? colorDiff : a.name.localeCompare(b.name);
                    default:
                        return a.name.localeCompare(b.name);
                }
            });

            // Update card count display
            const cardCountDisplay = document.getElementById('card-count-display');
            const cardCount = filteredCards.length;
            cardCountDisplay.textContent = `${cardCount} card${cardCount !== 1 ? 's' : ''}`;

            // Render all cards in the single list
            filteredCards.forEach(({ name, count, cardData, available, rarity }) => {
                const li = document.createElement('li');
                let cardImageHtml = '';
                if (cardData.imageUris) {
                    if (cardData.imageUris.normal) {
                        cardImageHtml = `<div class=\"card-image-container\"><img src=\"${cardData.imageUris.normal}\" alt=\"${cardData.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                    } else if (cardData.imageUris.small) {
                        cardImageHtml = `<div class=\"card-image-container\"><img src=\"${cardData.imageUris.small}\" alt=\"${cardData.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                    }
                }
                if (!cardImageHtml) {
                    cardImageHtml = `<div class='card-fallback-text'><strong>${cardData.name}</strong><br><span>${cardData.typeLine||''}</span></div>`;
                }
                let actionIcons = '';
                // Always include commander button position (top)
                if (isLegendaryCreature(cardData)) {
                    actionIcons += `<button class=\"icon-btn set-commander-btn\" data-card-name=\"${cardData.name.replace(/\"/g, '&quot;')}\" aria-label=\"Set as Commander\"><span class=\"icon crown\"></span></button>`;
                } else {
                    actionIcons += `<div class=\"icon-btn-placeholder\"></div>`;
                }
                // Always include add to deck button position (bottom)
                if (!isLegendaryCreature(cardData) || cardData.name !== commanderName) {
                    const inDeck = deckCounts[cardData.name] || 0;
                    if (count > inDeck) {
                        actionIcons += `<button class=\"icon-btn add-to-deck-btn\" data-card-name=\"${cardData.name.replace(/\"/g, '&quot;')}\" aria-label=\"Add to Deck\"><span class=\"icon plus\"></span></button>`;
                    } else {
                        actionIcons += `<div class=\"icon-btn-placeholder\"></div>`;
                    }
                } else {
                    actionIcons += `<div class=\"icon-btn-placeholder\"></div>`;
                }
                let countBadge = '';
                if (available >= 2) {
                    countBadge = `<span class=\"card-count-badge\">${available}</span>`;
                }
                li.innerHTML = `
                    <div class=\"card-pool-item\">
                        <div class=\"card-image-action-container\" data-card-name=\"${cardData.name.replace(/\"/g, '&quot;')}\">
                            ${cardImageHtml}
                            ${countBadge}
                            <div class=\"card-action-icons\">${actionIcons}</div>
                        </div>
                    </div>
                `;
                ul.appendChild(li);
            });
            // Add event listeners for commander buttons
            document.querySelectorAll('.set-commander-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    const cardName = this.getAttribute('data-card-name');
                    // Find the card data
                    let found = null;
                    for (const rarity in cardPool) {
                        if (cardPool[rarity][cardName]) {
                            found = cardDataMap[cardName];
                            break;
                        }
                    }
                    if (found) {
                        commanderDeck.commander = found;
                        renderCommanderDeck();
                        renderCardPool();
                    }
                });
            });
            // Add event listeners for add-to-deck buttons
            document.querySelectorAll('.add-to-deck-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    const cardName = this.getAttribute('data-card-name');
                    // Find the card data
                    let found = null;
                    for (const rarity in cardPool) {
                        if (cardPool[rarity][cardName]) {
                            found = cardDataMap[cardName];
                            break;
                        }
                    }
                    if (found) {
                        commanderDeck.cards.push(found);
                        renderCommanderDeck();
                        renderDeckCards();
                        renderCardPool();
                    }
                });
            });

            // Add event listeners for card container clicks
            document.querySelectorAll('.card-image-action-container').forEach(container => {
                container.addEventListener('click', function(e) {
                    // Don't trigger if clicking on action buttons
                    if (e.target.closest('.card-action-icons')) {
                        return;
                    }
                    const cardName = this.getAttribute('data-card-name');
                    if (cardName) {
                        showCardViewOverlay(cardName);
                    }
                });
            });
        }

        // Update renderBasicLands to use Scryfall SVG URIs for mana symbols
        function renderBasicLands() {
            const basicLandsList = document.getElementById('commander-deck-basic-lands');
            basicLandsList.innerHTML = '';

            // Map land types to their mana symbols
            const landToSymbol = {
                'Plains': '{W}',
                'Island': '{U}',
                'Swamp': '{B}',
                'Mountain': '{R}',
                'Forest': '{G}'
            };

            // For each basic land, show the mana symbol button and the input field side by side
            Object.keys(commanderDeck.basicLands).forEach(landType => {
                const count = commanderDeck.basicLands[landType];
                const symbol = landToSymbol[landType];
                const symbolHtml = createManaSymbolHtml(symbol, 28);

                const symbolButton = `<button class="quick-add-btn quick-add-btn-${landType.toLowerCase()}" data-land="${landType}" title="${landType}">
                    <span class="mana-symbol mana-${symbol.charAt(1).toLowerCase()}">
                        ${symbolHtml}
                    </span>
                </button>`;
                const li = document.createElement('li');
                li.innerHTML = `
                    <div class="basic-land-item" style="display: flex; align-items: center; gap: 1em;">
                        ${symbolButton}
                        <input type="number" class="land-input" data-land="${landType}" min="0" step="1" value="${count}" style="width: 3.5em; text-align: center; font-size: 1em; border-radius: 4px; border: 1px solid #ccc; padding: 2px 6px;" />
                    </div>
                `;
                basicLandsList.appendChild(li);
            });

            // Add event listeners for quick-add buttons
            document.querySelectorAll('.quick-add-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const landType = this.getAttribute('data-land');
                    commanderDeck.basicLands[landType]++;
                    renderBasicLands();
                    updateCommanderDeckStats();
                });
            });

            // Add event listeners for land input fields
            document.querySelectorAll('.land-input').forEach(input => {
                input.addEventListener('input', function() {
                    const landType = this.getAttribute('data-land');
                    let value = parseInt(this.value, 10);
                    if (isNaN(value) || value < 0) value = 0;
                    commanderDeck.basicLands[landType] = value;
                    updateCommanderDeckStats();
                });
            });
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {

            // Initialize loading state and fetch all required data
            setLoadingState(true);

            // Fetch both symbology and card sets data
            Promise.all([
                scryfallAPI.fetchSymbology().catch(error => {
                    console.warn('Failed to load symbology data:', error);
                    return null;
                }),
                fetch('js/cardSets.json').then(response => response.json()).catch(error => {
                    console.error('Error fetching card sets:', error);
                    return { sets: [] };
                })
            ]).then(([symbologyData, cardSetsData]) => {
                // Process symbology data
                if (symbologyData) {
                    symbologyData = symbologyData;
                    console.log('Symbology data loaded and cached');
                    populateColorFilterSymbols();
                }

                // Process card sets data
                cardSets = cardSetsData.sets;
                populateSetDropdown();

                // Select the first available set by default
                const firstEnabledSet = cardSets.find(set => set.enabled !== false);
                if (firstEnabledSet) {
                    document.getElementById('set-select').value = firstEnabledSet.code;
                    document.getElementById('set-select').dispatchEvent(new Event('change'));
                }

                // Render commander deck
                renderCommanderDeck();

                // End loading state
                setLoadingState(false);
            });

            // Set selection change
            document.getElementById('set-select').addEventListener('change', updateBoosterTypes);

            // Booster type selection change
            document.getElementById('booster-type').disabled = true;
            document.getElementById('booster-type').addEventListener('change', updateBoxSize);

            // Card pool control event listeners
            document.getElementById('sort-select').addEventListener('change', function() {
                filterState.sortBy = this.value;
                renderCardPool();
                updateActiveFiltersIndicator();
            });

            document.getElementById('filter-rarity').addEventListener('change', function() {
                filterState.rarityFilter = this.value;
                renderCardPool();
                updateActiveFiltersIndicator();
            });

            document.getElementById('filter-type').addEventListener('change', function() {
                filterState.typeFilter = this.value;
                renderCardPool();
                updateActiveFiltersIndicator();
            });

            document.getElementById('search-input').addEventListener('input', function() {
                filterState.searchQuery = this.value;
                renderCardPool();
                updateActiveFiltersIndicator();
            });

            document.getElementById('valid-commanders-only').addEventListener('change', function() {
                filterState.validCommandersOnly = this.checked;
                renderCardPool();
                updateActiveFiltersIndicator();
            });

            // Color filter event listeners
            const colorCheckboxes = ['w', 'u', 'b', 'r', 'g', 'c'];
            colorCheckboxes.forEach(color => {
                document.getElementById(`filter-color-${color}`).addEventListener('change', function() {
                    updateColorFilter();
                    renderCardPool();
                    updateActiveFiltersIndicator();
                });
            });

            // Helper function to update color filter state
            function updateColorFilter() {
                filterState.colorFilter = [];
                colorCheckboxes.forEach(color => {
                    const checkbox = document.getElementById(`filter-color-${color}`);
                    if (checkbox.checked) {
                        filterState.colorFilter.push(checkbox.value);
                    }
                });
            }

            // Toggle filters panel
            document.getElementById('toggle-filters-btn').addEventListener('click', function() {
                const filterGrid = document.getElementById('filter-grid');
                const filterHeader = document.querySelector('.filter-section-header');
                const toggleIcon = this.querySelector('.toggle-icon');
                const isCollapsed = filterGrid.classList.contains('collapsed');

                if (isCollapsed) {
                    filterGrid.classList.remove('collapsed');
                    filterHeader.classList.remove('compact');
                    toggleIcon.textContent = '‚ñº';
                    this.setAttribute('title', 'Collapse filters');
                } else {
                    filterGrid.classList.add('collapsed');
                    filterHeader.classList.add('compact');
                    toggleIcon.textContent = '‚ñ∂';
                    this.setAttribute('title', 'Expand filters');
                }
            });

            // Set initial tooltip for collapsed state
            document.getElementById('toggle-filters-btn').setAttribute('title', 'Expand filters');

            // Set initial compact state
            document.querySelector('.filter-section-header').classList.add('compact');

            // Toggle boosters panel
            document.getElementById('toggle-boosters-btn').addEventListener('click', function() {
                const boostersContent = document.getElementById('booster-display');
                const toggleIcon = this.querySelector('.toggle-boosters-icon');
                const isCollapsed = boostersContent.classList.contains('collapsed');

                if (isCollapsed) {
                    boostersContent.classList.remove('collapsed');
                    toggleIcon.textContent = '‚ñº';
                    this.setAttribute('title', 'Collapse boosters');
                } else {
                    boostersContent.classList.add('collapsed');
                    toggleIcon.textContent = '‚ñ∂';
                    this.setAttribute('title', 'Expand boosters');
                }
            });

            // Set initial tooltip for collapsed state
            document.getElementById('toggle-boosters-btn').setAttribute('title', 'Expand boosters');

            // Helper function to update active filters indicator
            function updateActiveFiltersIndicator() {
                const indicator = document.getElementById('active-filters-indicator');
                const hasActiveFilters =
                    filterState.rarityFilter !== 'all' ||
                    filterState.typeFilter !== 'all' ||
                    filterState.searchQuery !== '' ||
                    filterState.validCommandersOnly ||
                    filterState.colorFilter.length > 0;

                indicator.style.display = hasActiveFilters ? 'flex' : 'none';
            }

            document.getElementById('clear-filters-btn').addEventListener('click', function() {
                // Reset all filters
                filterState = {
                    sortBy: 'name',
                    rarityFilter: 'all',
                    typeFilter: 'all',
                    searchQuery: '',
                    validCommandersOnly: false,
                    colorFilter: []
                };

                // Reset UI elements
                document.getElementById('sort-select').value = 'name';
                document.getElementById('filter-rarity').value = 'all';
                document.getElementById('filter-type').value = 'all';
                document.getElementById('search-input').value = '';
                document.getElementById('valid-commanders-only').checked = false;

                // Reset color checkboxes
                colorCheckboxes.forEach(color => {
                    document.getElementById(`filter-color-${color}`).checked = false;
                });

                renderCardPool();
                updateActiveFiltersIndicator();
            });

            // Clear cache function (available for development purposes)
            // To clear cache programmatically, call: clearAllCache();
            function clearAllCache() {
                scryfallAPI.clearCache();
                scryfallAPI.clearSymbologyCache();
                console.log('Cache cleared!');
            }

                        // Clear deck button
            document.getElementById('clear-deck-btn').addEventListener('click', function() {
                if (commanderDeck.cards.length === 0 && !commanderDeck.commander &&
                    Object.values(commanderDeck.basicLands).every(count => count === 0)) {
                    alert('The deck is already empty.');
                    return;
                }

                if (confirm('Are you sure you want to clear the entire deck? This will remove all cards, the commander, and reset basic lands to zero.')) {
                    clearDeck();
                }
            });

            // Export deck button
            document.getElementById('export-deck-btn').addEventListener('click', showExportOverlay);

            // Export overlay event listeners
            document.getElementById('close-export-overlay').addEventListener('click', hideExportOverlay);
            document.getElementById('cancel-export-btn').addEventListener('click', hideExportOverlay);
            document.getElementById('copy-deck-btn').addEventListener('click', copyDeckToClipboard);

            // Card view overlay event listeners
            document.getElementById('close-card-view-overlay').addEventListener('click', hideCardViewOverlay);

            // Close overlay when clicking outside
            document.getElementById('export-overlay').addEventListener('click', function(e) {
                if (e.target === this) {
                    hideExportOverlay();
                }
            });

            document.getElementById('card-view-overlay').addEventListener('click', function(e) {
                if (e.target === this) {
                    hideCardViewOverlay();
                }
            });

            // Close overlay with Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    if (document.getElementById('export-overlay').style.display === 'flex') {
                        hideExportOverlay();
                    }
                    if (document.getElementById('card-view-overlay').style.display === 'flex') {
                        hideCardViewOverlay();
                    }
                }
            });

            // Open booster button
            document.getElementById('open-booster').addEventListener('click', function() {
                // If deck is not empty, prompt for confirmation
                if (commanderDeck.commander || (commanderDeck.cards && commanderDeck.cards.length > 0)) {
                    if (!confirm('You have a deck in progress. Are you sure you want to open a new box and reset your deck?')) {
                        return;
                    }
                }
                // Reset commander deck
                commanderDeck.commander = null;
                commanderDeck.cards = [];
                commanderDeck.basicLands = {
                    Plains: 0,
                    Island: 0,
                    Swamp: 0,
                    Mountain: 0,
                    Forest: 0
                };
                renderCommanderDeck();

                const setSelect = document.getElementById('set-select');
                const boosterTypeSelect = document.getElementById('booster-type');
                const boxSizeInput = document.getElementById('box-size');

                if (!setSelect.value || !boosterTypeSelect.value) {
                    alert('Please select a set and booster type.');
                    return;
                }

                const boxSize = parseInt(boxSizeInput.value);
                if (!boxSizeInput.value || isNaN(boxSize) || boxSize < 1) {
                    alert('Please enter a valid box size (positive integer).');
                    return;
                }

                console.log('Opening booster:', {
                    set: selectedSet.name,
                    boosterType: boosterTypeSelect.value,
                    boxSize: boxSize,
                    setData: setData,
                    bonusSheetData: bonusSheetData
                });

                // Simulate opening packs and display results
                const boosterDisplay = document.getElementById('booster-display');
                let output = '';

                // Card pool aggregation
                cardPool = {
                    mythic: {},
                    rare: {},
                    uncommon: {},
                    common: {}
                };
                // Store full card data for reference
                cardDataMap = {};

                // Helper: pick an item based on probability weights
                function pickWeighted(items) {
                    const total = items.reduce((sum, item) => sum + item.probability, 0);
                    let r = Math.random() * total;
                    for (const item of items) {
                        if (r < item.probability) return item;
                        r -= item.probability;
                    }
                    return items[items.length - 1]; // fallback
                }

                // Helper: get all cards from a set by rarity and collector number
                function getCardsFromSet(setCode, rarity, collectorNumbers, collectorNumberRanges, exclusions) {
                    let cardPool = [];
                    let cardData = null;
                    if (setData && setData.setCode === setCode) cardData = setData.cards;
                    else if (bonusSheetData && bonusSheetData.setCode === setCode) cardData = bonusSheetData.cards;
                    if (!cardData) return [];

                    // Filter by rarity
                    cardPool = cardData.filter(card => {
                        // Skip empty card objects (from the array structure)
                        if (!card || !card.name) return false;

                        if (rarity && card.rarity !== rarity) {
                            return false;
                        }
                        return true;
                    });

                    // Filter by collectorNumbers
                    if (collectorNumbers) {
                        cardPool = cardPool.filter(card => collectorNumbers.includes(card.collectorNumber));
                    }

                    // Filter by collectorNumberRanges
                    if (collectorNumberRanges) {
                        let validNumbers = new Set();
                        collectorNumberRanges.forEach(range => {
                            for (let n = range.start; n <= range.end; n++) validNumbers.add(n);
                        });
                        cardPool = cardPool.filter(card => validNumbers.has(card.collectorNumber));
                    }

                    // Exclude exclusions
                    if (exclusions) {
                        cardPool = cardPool.filter(card => !exclusions.includes(card.collectorNumber));
                    }

                    return cardPool;
                }

                // Main simulation
                const boosterType = boosterTypeSelect.value;
                const boosterConfig = selectedSet.boosterTypes[boosterType.charAt(0).toUpperCase() + boosterType.slice(1)];
                const slotsRaw = boosterConfig.slots;
                // Expand slots with 'slots' array into individual slot objects
                let slots = [];
                slotsRaw.forEach(slot => {
                    if (Array.isArray(slot.slots)) {
                        slot.slots.forEach(slotNum => {
                            // Create a shallow copy for each slot number
                            let slotCopy = Object.assign({}, slot);
                            delete slotCopy.slots;
                            slotCopy.slot = slotNum;
                            slots.push(slotCopy);
                        });
                    } else {
                        slots.push(slot);
                    }
                });

                for (let i = 0; i < boxSize; i++) {
                    let slotResults = '';
                    slots.forEach((slot, slotIdx) => {
                        let cardName = '(no card found)';
                        let cardRarity = null;
                        let attempts = 0;
                        let card = null;
                        while (attempts < 10) {
                            const pickedItem = pickWeighted(slot.items);
                            // Get card pool for this item
                            const cards = getCardsFromSet(
                                pickedItem.set,
                                pickedItem.rarity || pickedItem.rarities || slot.rarity,
                                pickedItem.collectorNumbers,
                                pickedItem.collectorNumberRanges,
                                pickedItem.exclusions
                            );
                            if (cards.length > 0) {
                                card = cards[Math.floor(Math.random() * cards.length)];
                                cardName = card.name + (card.rarity ? ` [${card.rarity}]` : '');
                                cardRarity = card.rarity ? card.rarity.toLowerCase() : null;
                                break;
                            }
                            attempts++;
                        }
                        // Aggregate card pool by rarity
                        if (card && cardRarity) {
                            let rarityKey = cardRarity;
                            if (rarityKey === 'mythic') rarityKey = 'mythic';
                            if (rarityKey === 'rare') rarityKey = 'rare';
                            if (rarityKey === 'uncommon') rarityKey = 'uncommon';
                            if (rarityKey === 'common') rarityKey = 'common';
                            if (cardPool[rarityKey]) {
                                if (!cardPool[rarityKey][card.name]) {
                                    cardPool[rarityKey][card.name] = 1;
                                    // Store full card data for reference
                                    cardDataMap[card.name] = card;
                                } else {
                                    cardPool[rarityKey][card.name]++;
                                }
                            }
                        }
                        let cardImageHtml = '';
                        if (card && card.imageUris) {
                            if (card.imageUris.normal) {
                                cardImageHtml = `<div class="card-image-container"><img src="${card.imageUris.normal}" alt="${card.name}" class="card-thumbnail" loading="lazy" onclick="showCardViewOverlay('${card.name.replace(/'/g, "\\'")}')" style="cursor: pointer;"></div>`;
                            } else if (card.imageUris.small) {
                                cardImageHtml = `<div class="card-image-container"><img src="${card.imageUris.small}" alt="${card.name}" class="card-thumbnail" loading="lazy" onclick="showCardViewOverlay('${card.name.replace(/'/g, "\\'")}')" style="cursor: pointer;"></div>`;
                            }
                        }
                        if (!cardImageHtml && card) {
                            cardImageHtml = `<div class='card-fallback-text' onclick="showCardViewOverlay('${card.name.replace(/'/g, "\\'")}')" style="cursor: pointer;"><strong>${card.name}</strong><br><span>${card.typeLine||''}</span></div>`;
                        }
                        slotResults += `
                            <details class="booster-panel">
                                <summary>Slot ${slotIdx + 1}: ${slot.name}</summary>
                                <div>${cardImageHtml}</div>
                            </details>
                        `;
                    });
                    output += `
                        <details class="booster-panel">
                            <summary>Booster ${i + 1}</summary>
                            <div>${slotResults}</div>
                        </details>
                    `;
                }

                // Update card pool title with set information
                updateCardPoolTitle();

                // Render card pool
                renderCardPool();

                boosterDisplay.innerHTML = output;

                // --- Dynamically create Expand/Collapse All Button ---
                const detailsList = boosterDisplay.querySelectorAll('details');
                let toggleAllBtn = document.getElementById('toggle-all-boosters');
                if (toggleAllBtn) toggleAllBtn.remove(); // Remove any previous button
                if (detailsList.length > 0) {
                    toggleAllBtn = document.createElement('button');
                    toggleAllBtn.id = 'toggle-all-boosters';
                    toggleAllBtn.className = 'secondary-button';
                    toggleAllBtn.style.marginBottom = '1em';
                    toggleAllBtn.textContent = 'Expand All';
                    let expanded = false;
                    toggleAllBtn.onclick = function() {
                        expanded = !expanded;
                        detailsList.forEach(d => d.open = expanded);
                        toggleAllBtn.textContent = expanded ? 'Collapse All' : 'Expand All';
                    };
                    boosterDisplay.prepend(toggleAllBtn);
                }

                // After renderCardPool is called, also render the commander deck
                renderCommanderDeck();
            });
        });
    </script>
</body>
</html>