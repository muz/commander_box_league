<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Commander Box League - Booster Simulator</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <div id="app">
        <header>
            <h1>Commander Box League</h1>
            <div class="cbl-description" style="margin-bottom: 1em; font-size: 1em;">
                <small>
                    This tool is for simulating virtual <a href="https://wpn.wizards.com/en/event/edge-of-eternities-commander-box-league" target="_blank" rel="noopener noreferrer">Commander Box League</a> deck building.
                </small>
            </div>
        </header>

        <main>
            <section id="controls">
                <div class="set-selection">
                    <label for="set-select">Select Set:</label>
                    <select id="set-select">
                        <option value="">Choose a set...</option>
                    </select>
                </div>

                <div class="booster-type">
                    <label for="booster-type">Booster Type:</label>
                    <select id="booster-type">
                        <option value="">Choose a booster type...</option>
                    </select>
                </div>

                <div class="box-size">
                    <label for="box-size">Box Size:</label>
                    <input type="number" id="box-size" min="1" step="1" placeholder="Enter box size">
                </div>

                <button id="open-booster" class="primary-button">Open Box!</button>
            </section>

            <section id="results">
                <div id="card-pool-and-deck-wrapper" style="display: flex; gap: 2em; flex-wrap: wrap; align-items: flex-start;">
                    <div id="card-pool-section">
                        <h3>Card Pool</h3>
                        <div id="card-pool-scroll" class="scroll-section">
                            <div id="card-pool">
                                <div class="card-pool-group" id="card-pool-mythic">
                                    <h4>Mythic Rare</h4>
                                    <ul class="card-pool-list" id="card-pool-list-mythic"></ul>
                                </div>
                                <div class="card-pool-group" id="card-pool-rare">
                                    <h4>Rare</h4>
                                    <ul class="card-pool-list" id="card-pool-list-rare"></ul>
                                </div>
                                <div class="card-pool-group" id="card-pool-uncommon">
                                    <h4>Uncommon</h4>
                                    <ul class="card-pool-list" id="card-pool-list-uncommon"></ul>
                                </div>
                                <div class="card-pool-group" id="card-pool-common">
                                    <h4>Common</h4>
                                    <ul class="card-pool-list" id="card-pool-list-common"></ul>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="commander-deck-section">
                        <div style="display: flex; align-items: center; gap: 1em; margin-bottom: 0.5em;">
                            <h3 style="margin: 0;">Deck</h3>
                            <div id="commander-deck-stats" class="deck-stats-pane">0 / 60</div>
                            <button id="clear-deck-btn" class="secondary-button small">Clear Deck</button>
                            <button id="export-deck-btn" class="secondary-button small">Export to Moxfield</button>
                        </div>
                        <div id="commander-deck-scroll" class="scroll-section">
                            <div id="commander-deck" class="card-pool-group">
                                <div class="card-pool-group">
                                    <h4>Commander</h4>
                                    <ul class="card-pool-list" id="commander-deck-commander"></ul>
                                </div>
                                <div class="card-pool-group">
                                    <h4>Deck</h4>
                                    <ul class="card-pool-list" id="commander-deck-cards"></ul>
                                </div>
                                <div class="card-pool-group">
                                    <h4>Basic Lands</h4>
                                    <ul class="card-pool-list" id="commander-deck-basic-lands"></ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="cache-status" class="cache-status">
                    <small>Status: <span id="status-info">Ready</span></small>
                    <small>Cache: <span id="cache-info">0 sets cached</span></small>
                    <button id="clear-cache" class="secondary-button small">Clear Cache</button>
                    <small class="api-note">Data fetched from <a href="https://scryfall.com" target="_blank" rel="noopener noreferrer">Scryfall.com</a></small>
                </div>
                <div id="boosters-section">
                    <h3>Boosters</h3>
                    <div id="booster-display">
                        <!-- Booster cards will be displayed here -->
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- Export Overlay -->
    <div id="export-overlay" class="overlay" style="display: none;">
        <div class="overlay-content">
            <div class="overlay-header">
                <h3>Export Deck to Moxfield</h3>
                <button id="close-export-overlay" class="close-btn">&times;</button>
            </div>
            <div class="overlay-body">
                <p>Copy the deck list below and paste it into Moxfield's import function:</p>
                <textarea id="deck-export-text" readonly></textarea>
            </div>
            <div class="overlay-footer">
                <button id="copy-deck-btn" class="primary-button">Copy to Clipboard</button>
                <button id="cancel-export-btn" class="secondary-button">Close</button>
            </div>
        </div>
    </div>

    <!-- GitHub link moved to bottom -->
    <footer style="text-align: center; margin-top: 2em;">
        <a href="https://github.com/muz/commander_box_league" class="github-link" target="_blank" rel="noopener noreferrer" style="display: inline-flex; align-items: center; gap: 0.5em; font-size: 1.1em;">
            <svg class="github-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 1.5em; height: 1.5em; vertical-align: middle;">
                <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
            </svg>
            View on GitHub
        </a>
    </footer>

    <script src="js/scryfall-api.js"></script>
    <script>
        // Global variables
        let cardSets = [];
        let selectedSet = null;
        let setData = null;
        let bonusSheetData = null;
        let scryfallAPI = new ScryfallAPI();
        // Commander deck state
        let commanderDeck = {
            commander: null, // { name, ... }
            cards: [], // for future deck-building
            basicLands: {
                Plains: 0,
                Island: 0,
                Swamp: 0,
                Mountain: 0,
                Forest: 0
            }
        };
        // Add at the top-level script scope:
        let cardPool = {
            mythic: {},
            rare: {},
            uncommon: {},
            common: {}
        };
        let cardDataMap = {};

        // Helper: check if a card is a Legendary Creature
        function isLegendaryCreature(card) {
            return card && card.typeLine && card.typeLine.includes('Legendary Creature');
        }

        // Render the deck cards in the deck UI
        function renderDeckCards() {
            const deckList = document.getElementById('commander-deck-cards');
            deckList.innerHTML = '';
            // Count cards in deck by name
            const deckCounts = {};
            commanderDeck.cards.forEach(card => {
                deckCounts[card.name] = (deckCounts[card.name] || 0) + 1;
            });
            Object.keys(deckCounts).sort().forEach(name => {
                const count = deckCounts[name];
                const card = commanderDeck.cards.find(c => c.name === name);
                const li = document.createElement('li');
                let cardImageHtml = '';
                if (card.imageUris) {
                    if (card.imageUris.normal) {
                        cardImageHtml = `<div class=\"card-image-container\"><img src=\"${card.imageUris.normal}\" alt=\"${card.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                    } else if (card.imageUris.small) {
                        cardImageHtml = `<div class=\"card-image-container\"><img src=\"${card.imageUris.small}\" alt=\"${card.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                    }
                }
                if (!cardImageHtml) {
                    cardImageHtml = `<div class='card-fallback-text'><strong>${card.name}</strong><br><span>${card.typeLine||''}</span></div>`;
                }
                let countBadge = '';
                if (count >= 2) {
                    countBadge = `<span class=\"card-count-badge\">${count}</span>`;
                }
                li.innerHTML = `
                    <div class=\"card-pool-item\">
                        <div class=\"card-image-action-container\">
                            ${cardImageHtml}
                            ${countBadge}
                            <div class=\"card-action-icons\"><button class=\"icon-btn remove-from-deck-btn\" data-card-name=\"${card.name.replace(/\"/g, '&quot;')}\" aria-label=\"Remove from Deck\"><span class=\"icon minus\"></span></button></div>
                        </div>
                    </div>
                `;
                deckList.appendChild(li);
            });
            // Remove event listeners
            document.querySelectorAll('.remove-from-deck-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    const cardName = this.getAttribute('data-card-name');
                    // Remove one copy from deck
                    const idx = commanderDeck.cards.findIndex(c => c.name === cardName);
                    if (idx !== -1) {
                        commanderDeck.cards.splice(idx, 1);
                        renderCommanderDeck();
                        renderDeckCards();
                        renderCardPool();
                    }
                });
            });
        }

        // Update renderCommanderDeck to also render deck cards
        function renderCommanderDeck() {
            // Commander
            const commanderList = document.getElementById('commander-deck-commander');
            commanderList.innerHTML = '';
            if (commanderDeck.commander) {
                const card = commanderDeck.commander;
                const li = document.createElement('li');
                let cardImageHtml = '';
                if (card.imageUris) {
                    if (card.imageUris.normal) {
                        cardImageHtml = `<div class=\"card-image-container\"><img src=\"${card.imageUris.normal}\" alt=\"${card.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                    } else if (card.imageUris.small) {
                        cardImageHtml = `<div class=\"card-image-container\"><img src=\"${card.imageUris.small}\" alt=\"${card.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                    }
                }
                if (!cardImageHtml) {
                    cardImageHtml = `<div class='card-fallback-text'><strong>${card.name}</strong><br><span>${card.typeLine||''}</span></div>`;
                }
                li.innerHTML = `
                    <div class=\"card-pool-item\">
                        <div class=\"card-image-action-container\">
                            ${cardImageHtml}
                            <div class=\"card-action-icons\"><button class=\"icon-btn unset-commander-btn\" aria-label=\"Remove as Commander\"><span class=\"icon minus\"></span></button></div>
                        </div>
                        <div class=\"card-pool-name\">${card.name}</div>
                    </div>
                `;
                commanderList.appendChild(li);
            }
            // Deck cards
            renderDeckCards();
            // Basic lands
            renderBasicLands();
            // Stats
            updateCommanderDeckStats();
            // Unset commander event
            const unsetBtn = document.querySelector('.unset-commander-btn');
            if (unsetBtn) {
                unsetBtn.addEventListener('click', function() {
                    commanderDeck.commander = null;
                    renderCommanderDeck();
                    renderCardPool();
                });
            }
        }

        // Update the stats pane
        function updateCommanderDeckStats() {
            const statsPane = document.getElementById('commander-deck-stats');
            const commanderCount = commanderDeck.commander ? 1 : 0;
            const deckCount = commanderDeck.cards.length;
            const basicLandsCount = Object.values(commanderDeck.basicLands).reduce((sum, count) => sum + count, 0);
            const totalCount = commanderCount + deckCount + basicLandsCount;
            statsPane.textContent = `${totalCount} / 60`;
        }

                // Clear the entire deck and return all cards to the pool
        function clearDeck() {
            if (commanderDeck.cards.length === 0 && !commanderDeck.commander &&
                Object.values(commanderDeck.basicLands).every(count => count === 0)) {
                return; // Nothing to clear
            }

            // Clear commander
            commanderDeck.commander = null;

            // Clear deck cards (they're already in the pool, so no need to add them back)
            commanderDeck.cards = [];

            // Clear basic lands
            commanderDeck.basicLands = {
                Plains: 0,
                Island: 0,
                Swamp: 0,
                Mountain: 0,
                Forest: 0
            };

            // Re-render everything
            renderCommanderDeck();
            renderCardPool();
        }

                // Generate deck list in Moxfield format
        function generateMoxfieldDeckList() {
            let deckList = '';

            // Add commander first (if exists)
            if (commanderDeck.commander) {
                const setCode = commanderDeck.commander.setCode || '';
                const collectorNumber = commanderDeck.commander.collectorNumber || '';
                deckList += `1 ${commanderDeck.commander.name}${setCode ? ` (${setCode}) ${collectorNumber}` : ''}\n`;
            }

            // Add deck cards
            const deckCounts = {};
            const cardDetails = {};
            commanderDeck.cards.forEach(card => {
                if (!deckCounts[card.name]) {
                    deckCounts[card.name] = 0;
                    cardDetails[card.name] = card;
                }
                deckCounts[card.name]++;
            });

            // Sort cards alphabetically
            Object.keys(deckCounts).sort().forEach(cardName => {
                const count = deckCounts[cardName];
                const card = cardDetails[cardName];
                const setCode = card.setCode || '';
                const collectorNumber = card.collectorNumber || '';
                deckList += `${count} ${cardName}${setCode ? ` (${setCode}) ${collectorNumber}` : ''}\n`;
            });

            // Add basic lands (no set code needed for basic lands)
            Object.keys(commanderDeck.basicLands).forEach(landType => {
                const count = commanderDeck.basicLands[landType];
                if (count > 0) {
                    deckList += `${count} ${landType}\n`;
                }
            });

            return deckList.trim();
        }

        // Show export overlay
        function showExportOverlay() {
            const deckList = generateMoxfieldDeckList();
            if (!deckList) {
                alert('Your deck is empty. Add some cards before exporting.');
                return;
            }

            document.getElementById('deck-export-text').value = deckList;
            document.getElementById('export-overlay').style.display = 'flex';
        }

        // Hide export overlay
        function hideExportOverlay() {
            document.getElementById('export-overlay').style.display = 'none';
        }

        // Copy deck list to clipboard
        async function copyDeckToClipboard() {
            try {
                const deckText = document.getElementById('deck-export-text').value;
                await navigator.clipboard.writeText(deckText);

                // Show success feedback
                const copyBtn = document.getElementById('copy-deck-btn');
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'Copied!';
                copyBtn.style.background = '#22c55e';

                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = '';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy to clipboard:', err);
                alert('Failed to copy to clipboard. Please select and copy the text manually.');
            }
        }

        // Fetch card sets data
        async function fetchCardSets() {
            try {
                const response = await fetch('js/cardSets.json');
                const data = await response.json();
                cardSets = data.sets;
                populateSetDropdown();
            } catch (error) {
                console.error('Error fetching card sets:', error);
            }
        }

        // Populate set dropdown
        function populateSetDropdown() {
            const setSelect = document.getElementById('set-select');

            // Clear existing options except the first one
            setSelect.innerHTML = '<option value="">Choose a set...</option>';

            // Add sets from JSON
            cardSets.forEach(set => {
                // Only include sets where enabled is not declared or is not false
                if (set.enabled === false) return;
                const option = document.createElement('option');
                option.value = set.code;
                option.textContent = set.name;
                setSelect.appendChild(option);
            });
        }

        // Fetch set data and bonus sheet data
        async function fetchSetData(setCode) {
            try {
                // Update status to loading
                updateStatus(`Fetching ${setCode} data...`);
                const setSelect = document.getElementById('set-select');
                const originalText = setSelect.options[setSelect.selectedIndex].text;
                setSelect.options[setSelect.selectedIndex].text = `${originalText} (Loading...)`;

                // Fetch main set data from Scryfall API
                setData = await scryfallAPI.fetchSetData(setCode);
                console.log(`Fetched set data for ${setCode}:`, setData);

                // Fetch bonus sheet data if it exists
                if (selectedSet.bonusSheet) {
                    updateStatus(`Fetching ${selectedSet.bonusSheet.code} bonus sheet...`);
                    bonusSheetData = await scryfallAPI.fetchSetData(selectedSet.bonusSheet.code);
                    console.log(`Fetched bonus sheet data for ${selectedSet.bonusSheet.code}:`, bonusSheetData);
                } else {
                    bonusSheetData = null;
                    console.log('No bonus sheet for this set');
                }

                // Restore original text and update status
                setSelect.options[setSelect.selectedIndex].text = originalText;
                updateStatus('Ready');

                // Update cache status
                updateCacheStatus();

            } catch (error) {
                console.error('Error fetching set data:', error);
                setData = null;
                bonusSheetData = null;

                // Restore original text and update status
                const setSelect = document.getElementById('set-select');
                const originalText = setSelect.options[setSelect.selectedIndex].text.replace(' (Loading...)', '');
                setSelect.options[setSelect.selectedIndex].text = originalText;
                updateStatus('Error loading data');

                alert(`Error fetching data for set ${setCode}: ${error.message}`);
            }
        }

        // Update cache status display
        function updateCacheStatus() {
            const cacheStats = scryfallAPI.getCacheStats();
            const cacheInfo = document.getElementById('cache-info');
            cacheInfo.textContent = `${cacheStats.size} sets cached`;
        }

        // Update status display
        function updateStatus(status) {
            const statusInfo = document.getElementById('status-info');
            statusInfo.textContent = status;
        }

        // Update booster types based on selected set
        async function updateBoosterTypes() {
            const boosterTypeSelect = document.getElementById('booster-type');
            const boxSizeInput = document.getElementById('box-size');
            const setSelect = document.getElementById('set-select');

            // Clear existing options
            boosterTypeSelect.innerHTML = '<option value="">Choose a booster type...</option>';
            boxSizeInput.value = '';

            if (setSelect.value) {
                selectedSet = cardSets.find(set => set.code === setSelect.value);

                if (selectedSet && selectedSet.boosterTypes) {
                    Object.keys(selectedSet.boosterTypes).forEach(boosterType => {
                        const boosterConfig = selectedSet.boosterTypes[boosterType];
                        const option = document.createElement('option');
                        option.value = boosterType.toLowerCase();
                        option.textContent = boosterType;
                        option.dataset.boxSize = boosterConfig.boxSize;
                        boosterTypeSelect.appendChild(option);
                    });
                }

                // Fetch set data and bonus sheet data
                await fetchSetData(selectedSet.code);
            } else {
                selectedSet = null;
                setData = null;
                bonusSheetData = null;
            }
        }

        // Update box size based on selected booster type
        function updateBoxSize() {
            const boosterTypeSelect = document.getElementById('booster-type');
            const boxSizeInput = document.getElementById('box-size');

            // Clear the input field
            boxSizeInput.value = '';

            if (boosterTypeSelect.value && selectedSet) {
                const boosterType = boosterTypeSelect.value;
                const boosterConfig = selectedSet.boosterTypes[boosterType.charAt(0).toUpperCase() + boosterType.slice(1)];

                if (boosterConfig && boosterConfig.boxSize) {
                    // Set the default box size as the input value
                    boxSizeInput.value = boosterConfig.boxSize;
                }
            }
        }

        // Move renderCardPool to top-level scope
        function renderCardPool() {
            const rarityMap = {
                mythic: 'card-pool-list-mythic',
                rare: 'card-pool-list-rare',
                uncommon: 'card-pool-list-uncommon',
                common: 'card-pool-list-common'
            };
            // Count cards in deck by name
            const deckCounts = {};
            commanderDeck.cards.forEach(card => {
                deckCounts[card.name] = (deckCounts[card.name] || 0) + 1;
            });
            // Exclude commander from add-to-deck
            const commanderName = commanderDeck.commander ? commanderDeck.commander.name : null;
            Object.keys(rarityMap).forEach(rarity => {
                const ul = document.getElementById(rarityMap[rarity]);
                ul.innerHTML = '';
                const cards = cardPool[rarity];
                const sortedNames = Object.keys(cards).sort();

                // Filter out cards that shouldn't be shown
                const visibleCards = [];
                sortedNames.forEach(name => {
                    const count = cards[name];
                    const cardData = cardDataMap[name];
                    if (!cardData) return;

                    const available = count - (deckCounts[cardData.name] || 0);
                    if (available <= 0) return; // Skip rendering this card if none are available
                    // Skip rendering if this card is the commander
                    if (commanderName && cardData.name === commanderName) return;

                    visibleCards.push({ name, count, cardData, available });
                });

                // Only show rarity section if there are visible cards
                if (visibleCards.length === 0) {
                    const rarityGroup = ul.closest('.card-pool-group');
                    if (rarityGroup) {
                        rarityGroup.style.display = 'none';
                    }
                    return;
                } else {
                    const rarityGroup = ul.closest('.card-pool-group');
                    if (rarityGroup) {
                        rarityGroup.style.display = 'block';
                    }
                }

                visibleCards.forEach(({ name, count, cardData, available }) => {
                    const li = document.createElement('li');
                    let cardImageHtml = '';
                    if (cardData.imageUris) {
                        if (cardData.imageUris.normal) {
                            cardImageHtml = `<div class=\"card-image-container\"><img src=\"${cardData.imageUris.normal}\" alt=\"${cardData.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                        } else if (cardData.imageUris.small) {
                            cardImageHtml = `<div class=\"card-image-container\"><img src=\"${cardData.imageUris.small}\" alt=\"${cardData.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                        }
                    }
                    if (!cardImageHtml) {
                        cardImageHtml = `<div class='card-fallback-text'><strong>${cardData.name}</strong><br><span>${cardData.typeLine||''}</span></div>`;
                    }
                    let actionIcons = '';
                    // Always include commander button position (top)
                    if (isLegendaryCreature(cardData)) {
                        actionIcons += `<button class=\"icon-btn set-commander-btn\" data-card-name=\"${cardData.name.replace(/\"/g, '&quot;')}\" aria-label=\"Set as Commander\"><span class=\"icon crown\"></span></button>`;
                    } else {
                        actionIcons += `<div class=\"icon-btn-placeholder\"></div>`;
                    }
                    // Always include add to deck button position (bottom)
                    if (!isLegendaryCreature(cardData) || cardData.name !== commanderName) {
                        const inDeck = deckCounts[cardData.name] || 0;
                        if (count > inDeck) {
                            actionIcons += `<button class=\"icon-btn add-to-deck-btn\" data-card-name=\"${cardData.name.replace(/\"/g, '&quot;')}\" aria-label=\"Add to Deck\"><span class=\"icon plus\"></span></button>`;
                        } else {
                            actionIcons += `<div class=\"icon-btn-placeholder\"></div>`;
                        }
                    } else {
                        actionIcons += `<div class=\"icon-btn-placeholder\"></div>`;
                    }
                    let countBadge = '';
                    if (available >= 2) {
                        countBadge = `<span class=\"card-count-badge\">${available}</span>`;
                    }
                    li.innerHTML = `
                        <div class=\"card-pool-item\">
                            <div class=\"card-image-action-container\">
                                ${cardImageHtml}
                                ${countBadge}
                                <div class=\"card-action-icons\">${actionIcons}</div>
                            </div>
                        </div>
                    `;
                    ul.appendChild(li);
                });
            });
            // Add event listeners for commander buttons
            document.querySelectorAll('.set-commander-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    const cardName = this.getAttribute('data-card-name');
                    // Find the card data
                    let found = null;
                    for (const rarity in cardPool) {
                        if (cardPool[rarity][cardName]) {
                            found = cardDataMap[cardName];
                            break;
                        }
                    }
                    if (found) {
                        commanderDeck.commander = found;
                        renderCommanderDeck();
                        renderCardPool();
                    }
                });
            });
            // Add event listeners for add-to-deck buttons
            document.querySelectorAll('.add-to-deck-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    const cardName = this.getAttribute('data-card-name');
                    // Find the card data
                    let found = null;
                    for (const rarity in cardPool) {
                        if (cardPool[rarity][cardName]) {
                            found = cardDataMap[cardName];
                            break;
                        }
                    }
                    if (found) {
                        commanderDeck.cards.push(found);
                        renderCommanderDeck();
                        renderDeckCards();
                        renderCardPool();
                    }
                });
            });
        }

        // Update renderBasicLands to use input fields for each basic land:
        function renderBasicLands() {
            const basicLandsList = document.getElementById('commander-deck-basic-lands');
            basicLandsList.innerHTML = '';

            // For each basic land, show the mana symbol button and the input field side by side
            Object.keys(commanderDeck.basicLands).forEach(landType => {
                const count = commanderDeck.basicLands[landType];
                let symbolButton = '';
                if (landType === 'Plains') {
                    symbolButton = `<button class="quick-add-btn quick-add-btn-plains" data-land="Plains" title="Plains">
                        <span class="mana-symbol mana-w">
                            <svg width="28" height="28" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="14" cy="14" r="10" fill="#fff" stroke="#d8cfa3" stroke-width="2"/>
                                <g stroke="#d8cfa3" stroke-width="1.5">
                                    <line x1="14" y1="3" x2="14" y2="7"/>
                                    <line x1="14" y1="21" x2="14" y2="25"/>
                                    <line x1="3" y1="14" x2="7" y2="14"/>
                                    <line x1="21" y1="14" x2="25" y2="14"/>
                                    <line x1="6.2" y1="6.2" x2="9" y2="9"/>
                                    <line x1="19" y1="19" x2="21.8" y2="21.8"/>
                                    <line x1="6.2" y1="21.8" x2="9" y2="19"/>
                                    <line x1="19" y1="9" x2="21.8" y2="6.2"/>
                                </g>
                                <circle cx="14" cy="14" r="5" fill="none" stroke="#d8cfa3" stroke-width="1.5"/>
                            </svg>
                        </span>
                    </button>`;
                } else if (landType === 'Island') {
                    symbolButton = `<button class="quick-add-btn quick-add-btn-island" data-land="Island" title="Island">
                        <span class="mana-symbol mana-u">
                            <svg width="28" height="28" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="14" cy="14" r="10" fill="#b4d6ef" stroke="#3a8fd8" stroke-width="2"/>
                                <path d="M14 7C14 7 20 15 14 21C8 15 14 7 14 7Z" fill="#3a8fd8" stroke="#3a8fd8" stroke-width="1.5"/>
                                <ellipse cx="14" cy="17.5" rx="3" ry="2" fill="#fff" fill-opacity="0.7"/>
                            </svg>
                        </span>
                    </button>`;
                } else if (landType === 'Swamp') {
                    symbolButton = `<button class="quick-add-btn quick-add-btn-swamp" data-land="Swamp" title="Swamp">
                        <span class="mana-symbol mana-b">
                            <svg width="28" height="28" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="14" cy="14" r="10" fill="#222" stroke="#888" stroke-width="2"/>
                                <ellipse cx="14" cy="16" rx="5" ry="6" fill="#888"/>
                                <ellipse cx="12" cy="15" rx="1.1" ry="1.5" fill="#222"/>
                                <ellipse cx="16" cy="15" rx="1.1" ry="1.5" fill="#222"/>
                                <ellipse cx="14" cy="19.5" rx="1.5" ry="0.7" fill="#222"/>
                                <rect x="11.5" y="20.5" width="1" height="2" rx="0.5" fill="#222"/>
                                <rect x="15.5" y="20.5" width="1" height="2" rx="0.5" fill="#222"/>
                            </svg>
                        </span>
                    </button>`;
                } else if (landType === 'Mountain') {
                    symbolButton = `<button class="quick-add-btn quick-add-btn-mountain" data-land="Mountain" title="Mountain">
                        <span class="mana-symbol mana-r">
                            <svg width="28" height="28" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="14" cy="14" r="10" fill="#f7b7a3" stroke="#e4572e" stroke-width="2"/>
                                <path d="M14 8C14 8 18 13 14 19C10 13 14 8 14 8Z" fill="#e4572e" stroke="#e4572e" stroke-width="1.5"/>
                                <path d="M14 13C14 13 16 15.5 14 18C12 15.5 14 13 14 13Z" fill="#fff" fill-opacity="0.7"/>
                            </svg>
                        </span>
                    </button>`;
                } else if (landType === 'Forest') {
                    symbolButton = `<button class="quick-add-btn quick-add-btn-forest" data-land="Forest" title="Forest">
                        <span class="mana-symbol mana-g">
                            <svg width="28" height="28" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="14" cy="14" r="10" fill="#b7e3b7" stroke="#3ca370" stroke-width="2"/>
                                <ellipse cx="14" cy="13" rx="5" ry="4" fill="#3ca370"/>
                                <ellipse cx="14" cy="10" rx="3.5" ry="2.5" fill="#3ca370"/>
                                <ellipse cx="14" cy="8" rx="2" ry="1.5" fill="#3ca370"/>
                                <rect x="12.5" y="15" width="3" height="5" rx="1.2" fill="#7bb661"/>
                            </svg>
                        </span>
                    </button>`;
                }
                const li = document.createElement('li');
                li.innerHTML = `
                    <div class="basic-land-item" style="display: flex; align-items: center; gap: 1em;">
                        ${symbolButton}
                        <input type="number" class="land-input" data-land="${landType}" min="0" step="1" value="${count}" style="width: 3.5em; text-align: center; font-size: 1em; border-radius: 4px; border: 1px solid #ccc; padding: 2px 6px;" />
                    </div>
                `;
                basicLandsList.appendChild(li);
            });

            // Add event listeners for quick-add buttons
            document.querySelectorAll('.quick-add-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const landType = this.getAttribute('data-land');
                    commanderDeck.basicLands[landType]++;
                    renderBasicLands();
                    updateCommanderDeckStats();
                });
            });

            // Add event listeners for land input fields
            document.querySelectorAll('.land-input').forEach(input => {
                input.addEventListener('input', function() {
                    const landType = this.getAttribute('data-land');
                    let value = parseInt(this.value, 10);
                    if (isNaN(value) || value < 0) value = 0;
                    commanderDeck.basicLands[landType] = value;
                    updateCommanderDeckStats();
                });
            });
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Hide card pool sections initially
            const rarityGroups = document.querySelectorAll('#card-pool .card-pool-group');
            rarityGroups.forEach(group => {
                group.style.display = 'none';
            });

            fetchCardSets();
            updateCacheStatus(); // Initialize cache status
            updateStatus('Ready'); // Initialize status

            // Set selection change
            document.getElementById('set-select').addEventListener('change', updateBoosterTypes);

            // Booster type selection change
            document.getElementById('booster-type').addEventListener('change', updateBoxSize);

            // Clear cache button
            document.getElementById('clear-cache').addEventListener('click', function() {
                scryfallAPI.clearCache();
                updateCacheStatus();
                alert('Cache cleared!');
            });

                        // Clear deck button
            document.getElementById('clear-deck-btn').addEventListener('click', function() {
                if (commanderDeck.cards.length === 0 && !commanderDeck.commander &&
                    Object.values(commanderDeck.basicLands).every(count => count === 0)) {
                    alert('The deck is already empty.');
                    return;
                }

                if (confirm('Are you sure you want to clear the entire deck? This will remove all cards, the commander, and reset basic lands to zero.')) {
                    clearDeck();
                }
            });

            // Export deck button
            document.getElementById('export-deck-btn').addEventListener('click', showExportOverlay);

            // Export overlay event listeners
            document.getElementById('close-export-overlay').addEventListener('click', hideExportOverlay);
            document.getElementById('cancel-export-btn').addEventListener('click', hideExportOverlay);
            document.getElementById('copy-deck-btn').addEventListener('click', copyDeckToClipboard);

            // Close overlay when clicking outside
            document.getElementById('export-overlay').addEventListener('click', function(e) {
                if (e.target === this) {
                    hideExportOverlay();
                }
            });

            // Close overlay with Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && document.getElementById('export-overlay').style.display === 'flex') {
                    hideExportOverlay();
                }
            });

            // Open booster button
            document.getElementById('open-booster').addEventListener('click', function() {
                // If deck is not empty, prompt for confirmation
                if (commanderDeck.commander || (commanderDeck.cards && commanderDeck.cards.length > 0)) {
                    if (!confirm('You have a deck in progress. Are you sure you want to open a new box and reset your deck?')) {
                        return;
                    }
                }
                // Reset commander deck
                commanderDeck.commander = null;
                commanderDeck.cards = [];
                commanderDeck.basicLands = {
                    Plains: 0,
                    Island: 0,
                    Swamp: 0,
                    Mountain: 0,
                    Forest: 0
                };
                renderCommanderDeck();

                const setSelect = document.getElementById('set-select');
                const boosterTypeSelect = document.getElementById('booster-type');
                const boxSizeInput = document.getElementById('box-size');

                if (!setSelect.value || !boosterTypeSelect.value) {
                    alert('Please select a set and booster type.');
                    return;
                }

                const boxSize = parseInt(boxSizeInput.value);
                if (!boxSizeInput.value || isNaN(boxSize) || boxSize < 1) {
                    alert('Please enter a valid box size (positive integer).');
                    return;
                }

                console.log('Opening booster:', {
                    set: selectedSet.name,
                    boosterType: boosterTypeSelect.value,
                    boxSize: boxSize,
                    setData: setData,
                    bonusSheetData: bonusSheetData
                });

                // Simulate opening packs and display results
                const boosterDisplay = document.getElementById('booster-display');
                let output = '';

                // Card pool aggregation
                cardPool = {
                    mythic: {},
                    rare: {},
                    uncommon: {},
                    common: {}
                };
                // Store full card data for reference
                cardDataMap = {};

                // Helper: pick an item based on probability weights
                function pickWeighted(items) {
                    const total = items.reduce((sum, item) => sum + item.probability, 0);
                    let r = Math.random() * total;
                    for (const item of items) {
                        if (r < item.probability) return item;
                        r -= item.probability;
                    }
                    return items[items.length - 1]; // fallback
                }

                // Helper: get all cards from a set by rarity and collector number
                function getCardsFromSet(setCode, rarity, collectorNumbers, collectorNumberRanges, exclusions) {
                    let cardPool = [];
                    let cardData = null;
                    if (setData && setData.setCode === setCode) cardData = setData.cards;
                    else if (bonusSheetData && bonusSheetData.setCode === setCode) cardData = bonusSheetData.cards;
                    if (!cardData) return [];

                    // Filter by rarity
                    cardPool = cardData.filter(card => {
                        // Skip empty card objects (from the array structure)
                        if (!card || !card.name) return false;

                        if (rarity && card.rarity !== rarity) {
                            return false;
                        }
                        return true;
                    });

                    // Filter by collectorNumbers
                    if (collectorNumbers) {
                        cardPool = cardPool.filter(card => collectorNumbers.includes(card.collectorNumber));
                    }

                    // Filter by collectorNumberRanges
                    if (collectorNumberRanges) {
                        let validNumbers = new Set();
                        collectorNumberRanges.forEach(range => {
                            for (let n = range.start; n <= range.end; n++) validNumbers.add(n);
                        });
                        cardPool = cardPool.filter(card => validNumbers.has(card.collectorNumber));
                    }

                    // Exclude exclusions
                    if (exclusions) {
                        cardPool = cardPool.filter(card => !exclusions.includes(card.collectorNumber));
                    }

                    return cardPool;
                }

                // Main simulation
                const boosterType = boosterTypeSelect.value;
                const boosterConfig = selectedSet.boosterTypes[boosterType.charAt(0).toUpperCase() + boosterType.slice(1)];
                const slotsRaw = boosterConfig.slots;
                // Expand slots with 'slots' array into individual slot objects
                let slots = [];
                slotsRaw.forEach(slot => {
                    if (Array.isArray(slot.slots)) {
                        slot.slots.forEach(slotNum => {
                            // Create a shallow copy for each slot number
                            let slotCopy = Object.assign({}, slot);
                            delete slotCopy.slots;
                            slotCopy.slot = slotNum;
                            slots.push(slotCopy);
                        });
                    } else {
                        slots.push(slot);
                    }
                });

                for (let i = 0; i < boxSize; i++) {
                    let slotResults = '';
                    slots.forEach((slot, slotIdx) => {
                        let cardName = '(no card found)';
                        let cardRarity = null;
                        let attempts = 0;
                        let card = null;
                        while (attempts < 10) {
                            const pickedItem = pickWeighted(slot.items);
                            // Get card pool for this item
                            const cards = getCardsFromSet(
                                pickedItem.set,
                                pickedItem.rarity || pickedItem.rarities || slot.rarity,
                                pickedItem.collectorNumbers,
                                pickedItem.collectorNumberRanges,
                                pickedItem.exclusions
                            );
                            if (cards.length > 0) {
                                card = cards[Math.floor(Math.random() * cards.length)];
                                cardName = card.name + (card.rarity ? ` [${card.rarity}]` : '');
                                cardRarity = card.rarity ? card.rarity.toLowerCase() : null;
                                break;
                            }
                            attempts++;
                        }
                        // Aggregate card pool by rarity
                        if (card && cardRarity) {
                            let rarityKey = cardRarity;
                            if (rarityKey === 'mythic') rarityKey = 'mythic';
                            if (rarityKey === 'rare') rarityKey = 'rare';
                            if (rarityKey === 'uncommon') rarityKey = 'uncommon';
                            if (rarityKey === 'common') rarityKey = 'common';
                            if (cardPool[rarityKey]) {
                                if (!cardPool[rarityKey][card.name]) {
                                    cardPool[rarityKey][card.name] = 1;
                                    // Store full card data for reference
                                    cardDataMap[card.name] = card;
                                } else {
                                    cardPool[rarityKey][card.name]++;
                                }
                            }
                        }
                        let cardImageHtml = '';
                        if (card && card.imageUris) {
                            if (card.imageUris.normal) {
                                cardImageHtml = `<div class="card-image-container"><img src="${card.imageUris.normal}" alt="${card.name}" class="card-thumbnail" loading="lazy"></div>`;
                            } else if (card.imageUris.small) {
                                cardImageHtml = `<div class="card-image-container"><img src="${card.imageUris.small}" alt="${card.name}" class="card-thumbnail" loading="lazy"></div>`;
                            }
                        }
                        if (!cardImageHtml && card) {
                            cardImageHtml = `<div class='card-fallback-text'><strong>${card.name}</strong><br><span>${card.typeLine||''}</span></div>`;
                        }
                        slotResults += `
                            <details class="booster-panel">
                                <summary>Slot ${slotIdx + 1}: ${slot.name}</summary>
                                <div>${cardImageHtml}</div>
                            </details>
                        `;
                    });
                    output += `
                        <details class="booster-panel">
                            <summary>Booster ${i + 1}</summary>
                            <div>${slotResults}</div>
                        </details>
                    `;
                }

                // Render card pool
                renderCardPool();

                boosterDisplay.innerHTML = output;

                // --- Dynamically create Expand/Collapse All Button ---
                const detailsList = boosterDisplay.querySelectorAll('details');
                let toggleAllBtn = document.getElementById('toggle-all-boosters');
                if (toggleAllBtn) toggleAllBtn.remove(); // Remove any previous button
                if (detailsList.length > 0) {
                    toggleAllBtn = document.createElement('button');
                    toggleAllBtn.id = 'toggle-all-boosters';
                    toggleAllBtn.className = 'secondary-button';
                    toggleAllBtn.style.marginBottom = '1em';
                    toggleAllBtn.textContent = 'Expand All';
                    let expanded = false;
                    toggleAllBtn.onclick = function() {
                        expanded = !expanded;
                        detailsList.forEach(d => d.open = expanded);
                        toggleAllBtn.textContent = expanded ? 'Collapse All' : 'Expand All';
                    };
                    boosterDisplay.prepend(toggleAllBtn);
                }

                // After renderCardPool is called, also render the commander deck
                renderCommanderDeck();
            });
        });
    </script>
</body>
</html>