<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Commander Box League - Booster Simulator</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <div id="app">
        <header>
            <h1>Commander Box League</h1>
            <h2>Booster Simulator</h2>
            <a href="https://github.com/muz/commander_box_league" class="github-link" target="_blank" rel="noopener noreferrer">
                <svg class="github-icon" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                </svg>
                View on GitHub
            </a>
        </header>

        <main>
            <section id="controls">
                <div class="set-selection">
                    <label for="set-select">Select Set:</label>
                    <select id="set-select">
                        <option value="">Choose a set...</option>
                    </select>
                    <div id="loading-indicator" class="loading-indicator" style="display: none;">
                        <span class="loading-spinner"></span>
                        <span>Fetching card data from Scryfall...</span>
                    </div>
                </div>

                <div class="booster-type">
                    <label for="booster-type">Booster Type:</label>
                    <select id="booster-type">
                        <option value="">Choose a booster type...</option>
                    </select>
                </div>

                <div class="box-size">
                    <label for="box-size">Box Size:</label>
                    <input type="number" id="box-size" min="1" step="1" placeholder="Enter box size">
                </div>

                <button id="open-booster" class="primary-button">Open Box!</button>

                <div id="cache-status" class="cache-status">
                    <small>Cache: <span id="cache-info">0 sets cached</span></small>
                    <button id="clear-cache" class="secondary-button small">Clear Cache</button>
                    <small class="api-note">Data fetched from <a href="https://scryfall.com" target="_blank" rel="noopener noreferrer">Scryfall.com</a></small>
                </div>
            </section>

            <section id="results">
                <div id="card-pool-and-deck-wrapper" style="display: flex; gap: 2em; flex-wrap: wrap; align-items: flex-start;">
                    <div id="card-pool-section">
                        <h3>Card Pool</h3>
                        <div id="card-pool-scroll" class="scroll-section">
                            <div id="card-pool">
                                <div class="card-pool-group" id="card-pool-mythic">
                                    <h4>Mythic Rare</h4>
                                    <ul class="card-pool-list" id="card-pool-list-mythic"></ul>
                                </div>
                                <div class="card-pool-group" id="card-pool-rare">
                                    <h4>Rare</h4>
                                    <ul class="card-pool-list" id="card-pool-list-rare"></ul>
                                </div>
                                <div class="card-pool-group" id="card-pool-uncommon">
                                    <h4>Uncommon</h4>
                                    <ul class="card-pool-list" id="card-pool-list-uncommon"></ul>
                                </div>
                                <div class="card-pool-group" id="card-pool-common">
                                    <h4>Common</h4>
                                    <ul class="card-pool-list" id="card-pool-list-common"></ul>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="commander-deck-section">
                        <div style="display: flex; align-items: center; gap: 1em; margin-bottom: 0.5em;">
                            <h3 style="margin: 0;">Commander Deck</h3>
                            <div id="commander-deck-stats" class="deck-stats-pane">0 / 60 cards</div>
                        </div>
                        <div id="commander-deck-scroll" class="scroll-section">
                            <div id="commander-deck" class="card-pool-group">
                                <div class="card-pool-group">
                                    <h4>Commander</h4>
                                    <ul class="card-pool-list" id="commander-deck-commander"></ul>
                                </div>
                                <div class="card-pool-group">
                                    <h4>Deck Cards</h4>
                                    <ul class="card-pool-list" id="commander-deck-cards"></ul>
                                </div>
                                <div class="card-pool-group">
                                    <h4>Basic Lands</h4>
                                    <ul class="card-pool-list" id="commander-deck-basic-lands"></ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="boosters-section">
                    <h3>Boosters</h3>
                    <div id="booster-display">
                        <!-- Booster cards will be displayed here -->
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script src="js/scryfall-api.js"></script>
    <script>
        // Global variables
        let cardSets = [];
        let selectedSet = null;
        let setData = null;
        let bonusSheetData = null;
        let scryfallAPI = new ScryfallAPI();
        // Commander deck state
        let commanderDeck = {
            commander: null, // { name, ... }
            cards: [], // for future deck-building
            basicLands: {
                Plains: 0,
                Island: 0,
                Swamp: 0,
                Mountain: 0,
                Forest: 0,
                Wastes: 0
            }
        };
        // Add at the top-level script scope:
        let cardPool = {
            mythic: {},
            rare: {},
            uncommon: {},
            common: {}
        };
        let cardDataMap = {};

        // Helper: check if a card is a Legendary Creature
        function isLegendaryCreature(card) {
            return card && card.typeLine && card.typeLine.includes('Legendary Creature');
        }

        // Render the deck cards in the deck UI
        function renderDeckCards() {
            const deckList = document.getElementById('commander-deck-cards');
            deckList.innerHTML = '';
            // Count cards in deck by name
            const deckCounts = {};
            commanderDeck.cards.forEach(card => {
                deckCounts[card.name] = (deckCounts[card.name] || 0) + 1;
            });
            Object.keys(deckCounts).sort().forEach(name => {
                const count = deckCounts[name];
                const card = commanderDeck.cards.find(c => c.name === name);
                const li = document.createElement('li');
                let cardImageHtml = '';
                if (card.imageUris) {
                    if (card.imageUris.normal) {
                        cardImageHtml = `<div class=\"card-image-container\"><img src=\"${card.imageUris.normal}\" alt=\"${card.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                    } else if (card.imageUris.small) {
                        cardImageHtml = `<div class=\"card-image-container\"><img src=\"${card.imageUris.small}\" alt=\"${card.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                    }
                }
                if (!cardImageHtml) {
                    cardImageHtml = `<div class='card-fallback-text'><strong>${card.name}</strong><br><span>${card.typeLine||''}</span></div>`;
                }
                let countBadge = '';
                if (count >= 2) {
                    countBadge = `<span class=\"card-count-badge\">${count}</span>`;
                }
                li.innerHTML = `
                    <div class=\"card-pool-item\">
                        <div class=\"card-image-action-container\">
                            ${cardImageHtml}
                            ${countBadge}
                            <div class=\"card-action-icons\"><button class=\"icon-btn remove-from-deck-btn\" data-card-name=\"${card.name.replace(/\"/g, '&quot;')}\" aria-label=\"Remove from Deck\"><span class=\"icon minus\"></span></button></div>
                        </div>
                    </div>
                `;
                deckList.appendChild(li);
            });
            // Remove event listeners
            document.querySelectorAll('.remove-from-deck-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    const cardName = this.getAttribute('data-card-name');
                    // Remove one copy from deck
                    const idx = commanderDeck.cards.findIndex(c => c.name === cardName);
                    if (idx !== -1) {
                        commanderDeck.cards.splice(idx, 1);
                        renderCommanderDeck();
                        renderDeckCards();
                        renderCardPool();
                    }
                });
            });
        }

        // Update renderCommanderDeck to also render deck cards
        function renderCommanderDeck() {
            // Commander
            const commanderList = document.getElementById('commander-deck-commander');
            commanderList.innerHTML = '';
            if (commanderDeck.commander) {
                const card = commanderDeck.commander;
                const li = document.createElement('li');
                let cardImageHtml = '';
                if (card.imageUris) {
                    if (card.imageUris.normal) {
                        cardImageHtml = `<div class=\"card-image-container\"><img src=\"${card.imageUris.normal}\" alt=\"${card.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                    } else if (card.imageUris.small) {
                        cardImageHtml = `<div class=\"card-image-container\"><img src=\"${card.imageUris.small}\" alt=\"${card.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                    }
                }
                if (!cardImageHtml) {
                    cardImageHtml = `<div class='card-fallback-text'><strong>${card.name}</strong><br><span>${card.typeLine||''}</span></div>`;
                }
                li.innerHTML = `
                    <div class=\"card-pool-item\">
                        <div class=\"card-image-action-container\">
                            ${cardImageHtml}
                            <div class=\"card-action-icons\"><button class=\"icon-btn unset-commander-btn\" aria-label=\"Remove as Commander\"><span class=\"icon minus\"></span></button></div>
                        </div>
                        <div class=\"card-pool-name\">${card.name}</div>
                    </div>
                `;
                commanderList.appendChild(li);
            }
            // Deck cards
            renderDeckCards();
            // Basic lands
            renderBasicLands();
            // Stats
            updateCommanderDeckStats();
            // Unset commander event
            const unsetBtn = document.querySelector('.unset-commander-btn');
            if (unsetBtn) {
                unsetBtn.addEventListener('click', function() {
                    commanderDeck.commander = null;
                    renderCommanderDeck();
                    renderCardPool();
                });
            }
        }

        // Update the stats pane
        function updateCommanderDeckStats() {
            const statsPane = document.getElementById('commander-deck-stats');
            const commanderCount = commanderDeck.commander ? 1 : 0;
            const deckCount = commanderDeck.cards.length;
            const basicLandsCount = Object.values(commanderDeck.basicLands).reduce((sum, count) => sum + count, 0);
            const totalCount = commanderCount + deckCount + basicLandsCount;
            statsPane.textContent = `${totalCount} / 60 cards`;
        }

        // Fetch card sets data
        async function fetchCardSets() {
            try {
                const response = await fetch('js/cardSets.json');
                const data = await response.json();
                cardSets = data.sets;
                populateSetDropdown();
            } catch (error) {
                console.error('Error fetching card sets:', error);
            }
        }

        // Populate set dropdown
        function populateSetDropdown() {
            const setSelect = document.getElementById('set-select');

            // Clear existing options except the first one
            setSelect.innerHTML = '<option value="">Choose a set...</option>';

            // Add sets from JSON
            cardSets.forEach(set => {
                // Only include sets where enabled is not declared or is not false
                if (set.enabled === false) return;
                const option = document.createElement('option');
                option.value = set.code;
                option.textContent = set.name;
                setSelect.appendChild(option);
            });
        }

        // Fetch set data and bonus sheet data
        async function fetchSetData(setCode) {
            try {
                // Show loading indicator
                const loadingIndicator = document.getElementById('loading-indicator');
                const setSelect = document.getElementById('set-select');
                const originalText = setSelect.options[setSelect.selectedIndex].text;
                setSelect.options[setSelect.selectedIndex].text = `${originalText} (Loading...)`;
                loadingIndicator.style.display = 'flex';

                // Fetch main set data from Scryfall API
                setData = await scryfallAPI.fetchSetData(setCode);
                console.log(`Fetched set data for ${setCode}:`, setData);

                // Fetch bonus sheet data if it exists
                if (selectedSet.bonusSheet) {
                    bonusSheetData = await scryfallAPI.fetchSetData(selectedSet.bonusSheet.code);
                    console.log(`Fetched bonus sheet data for ${selectedSet.bonusSheet.code}:`, bonusSheetData);
                } else {
                    bonusSheetData = null;
                    console.log('No bonus sheet for this set');
                }

                // Hide loading indicator and restore original text
                loadingIndicator.style.display = 'none';
                setSelect.options[setSelect.selectedIndex].text = originalText;

                // Update cache status
                updateCacheStatus();

            } catch (error) {
                console.error('Error fetching set data:', error);
                setData = null;
                bonusSheetData = null;

                // Hide loading indicator and restore original text
                const loadingIndicator = document.getElementById('loading-indicator');
                const setSelect = document.getElementById('set-select');
                const originalText = setSelect.options[setSelect.selectedIndex].text.replace(' (Loading...)', '');
                setSelect.options[setSelect.selectedIndex].text = originalText;
                loadingIndicator.style.display = 'none';

                alert(`Error fetching data for set ${setCode}: ${error.message}`);
            }
        }

        // Update cache status display
        function updateCacheStatus() {
            const cacheStats = scryfallAPI.getCacheStats();
            const cacheInfo = document.getElementById('cache-info');
            cacheInfo.textContent = `${cacheStats.size} sets cached`;
        }

        // Update booster types based on selected set
        async function updateBoosterTypes() {
            const boosterTypeSelect = document.getElementById('booster-type');
            const boxSizeInput = document.getElementById('box-size');
            const setSelect = document.getElementById('set-select');

            // Clear existing options
            boosterTypeSelect.innerHTML = '<option value="">Choose a booster type...</option>';
            boxSizeInput.value = '';

            if (setSelect.value) {
                selectedSet = cardSets.find(set => set.code === setSelect.value);

                if (selectedSet && selectedSet.boosterTypes) {
                    Object.keys(selectedSet.boosterTypes).forEach(boosterType => {
                        const boosterConfig = selectedSet.boosterTypes[boosterType];
                        const option = document.createElement('option');
                        option.value = boosterType.toLowerCase();
                        option.textContent = boosterType;
                        option.dataset.boxSize = boosterConfig.boxSize;
                        boosterTypeSelect.appendChild(option);
                    });
                }

                // Fetch set data and bonus sheet data
                await fetchSetData(selectedSet.code);
            } else {
                selectedSet = null;
                setData = null;
                bonusSheetData = null;
            }
        }

        // Update box size based on selected booster type
        function updateBoxSize() {
            const boosterTypeSelect = document.getElementById('booster-type');
            const boxSizeInput = document.getElementById('box-size');

            // Clear the input field
            boxSizeInput.value = '';

            if (boosterTypeSelect.value && selectedSet) {
                const boosterType = boosterTypeSelect.value;
                const boosterConfig = selectedSet.boosterTypes[boosterType.charAt(0).toUpperCase() + boosterType.slice(1)];

                if (boosterConfig && boosterConfig.boxSize) {
                    // Set the default box size as the input value
                    boxSizeInput.value = boosterConfig.boxSize;
                }
            }
        }

        // Move renderCardPool to top-level scope
        function renderCardPool() {
            const rarityMap = {
                mythic: 'card-pool-list-mythic',
                rare: 'card-pool-list-rare',
                uncommon: 'card-pool-list-uncommon',
                common: 'card-pool-list-common'
            };
            // Count cards in deck by name
            const deckCounts = {};
            commanderDeck.cards.forEach(card => {
                deckCounts[card.name] = (deckCounts[card.name] || 0) + 1;
            });
            // Exclude commander from add-to-deck
            const commanderName = commanderDeck.commander ? commanderDeck.commander.name : null;
            Object.keys(rarityMap).forEach(rarity => {
                const ul = document.getElementById(rarityMap[rarity]);
                ul.innerHTML = '';
                const cards = cardPool[rarity];
                const sortedNames = Object.keys(cards).sort();

                // Filter out cards that shouldn't be shown
                const visibleCards = [];
                sortedNames.forEach(name => {
                    const count = cards[name];
                    const cardData = cardDataMap[name];
                    if (!cardData) return;

                    const available = count - (deckCounts[cardData.name] || 0);
                    if (available <= 0) return; // Skip rendering this card if none are available
                    // Skip rendering if this card is the commander
                    if (commanderName && cardData.name === commanderName) return;

                    visibleCards.push({ name, count, cardData, available });
                });

                // Only show rarity section if there are visible cards
                if (visibleCards.length === 0) {
                    const rarityGroup = ul.closest('.card-pool-group');
                    if (rarityGroup) {
                        rarityGroup.style.display = 'none';
                    }
                    return;
                } else {
                    const rarityGroup = ul.closest('.card-pool-group');
                    if (rarityGroup) {
                        rarityGroup.style.display = 'block';
                    }
                }

                visibleCards.forEach(({ name, count, cardData, available }) => {
                    const li = document.createElement('li');
                    let cardImageHtml = '';
                    if (cardData.imageUris) {
                        if (cardData.imageUris.normal) {
                            cardImageHtml = `<div class=\"card-image-container\"><img src=\"${cardData.imageUris.normal}\" alt=\"${cardData.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                        } else if (cardData.imageUris.small) {
                            cardImageHtml = `<div class=\"card-image-container\"><img src=\"${cardData.imageUris.small}\" alt=\"${cardData.name}\" class=\"card-thumbnail\" loading=\"lazy\"></div>`;
                        }
                    }
                    if (!cardImageHtml) {
                        cardImageHtml = `<div class='card-fallback-text'><strong>${cardData.name}</strong><br><span>${cardData.typeLine||''}</span></div>`;
                    }
                    let actionIcons = '';
                    if (isLegendaryCreature(cardData)) {
                        actionIcons += `<button class=\"icon-btn set-commander-btn\" data-card-name=\"${cardData.name.replace(/\"/g, '&quot;')}\" aria-label=\"Set as Commander\"><span class=\"icon crown\"></span></button>`;
                    }
                    if (!isLegendaryCreature(cardData) || cardData.name !== commanderName) {
                        const inDeck = deckCounts[cardData.name] || 0;
                        if (count > inDeck) {
                            actionIcons += `<button class=\"icon-btn add-to-deck-btn\" data-card-name=\"${cardData.name.replace(/\"/g, '&quot;')}\" aria-label=\"Add to Deck\"><span class=\"icon plus\"></span></button>`;
                        }
                    }
                    let countBadge = '';
                    if (available >= 2) {
                        countBadge = `<span class=\"card-count-badge\">${available}</span>`;
                    }
                    li.innerHTML = `
                        <div class=\"card-pool-item\">
                            <div class=\"card-image-action-container\">
                                ${cardImageHtml}
                                ${countBadge}
                                <div class=\"card-action-icons\">${actionIcons}</div>
                            </div>
                        </div>
                    `;
                    ul.appendChild(li);
                });
            });
            // Add event listeners for commander buttons
            document.querySelectorAll('.set-commander-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    const cardName = this.getAttribute('data-card-name');
                    // Find the card data
                    let found = null;
                    for (const rarity in cardPool) {
                        if (cardPool[rarity][cardName]) {
                            found = cardDataMap[cardName];
                            break;
                        }
                    }
                    if (found) {
                        commanderDeck.commander = found;
                        renderCommanderDeck();
                        renderCardPool();
                    }
                });
            });
            // Add event listeners for add-to-deck buttons
            document.querySelectorAll('.add-to-deck-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    const cardName = this.getAttribute('data-card-name');
                    // Find the card data
                    let found = null;
                    for (const rarity in cardPool) {
                        if (cardPool[rarity][cardName]) {
                            found = cardDataMap[cardName];
                            break;
                        }
                    }
                    if (found) {
                        commanderDeck.cards.push(found);
                        renderCommanderDeck();
                        renderDeckCards();
                        renderCardPool();
                    }
                });
            });
        }

        // Update renderBasicLands to include a quick-add panel:
        function renderBasicLands() {
            const basicLandsList = document.getElementById('commander-deck-basic-lands');
            basicLandsList.innerHTML = '';

            // Add quick-add panel
            const quickAddPanel = document.createElement('div');
            quickAddPanel.className = 'basic-lands-quick-add';
            quickAddPanel.innerHTML = `
                <div class="quick-add-label">Quick Add:</div>
                <div class="quick-add-buttons">
                    <button class="quick-add-btn" data-land="Plains">Plains</button>
                    <button class="quick-add-btn" data-land="Island">Island</button>
                    <button class="quick-add-btn" data-land="Swamp">Swamp</button>
                    <button class="quick-add-btn" data-land="Mountain">Mountain</button>
                    <button class="quick-add-btn" data-land="Forest">Forest</button>
                    <button class="quick-add-btn" data-land="Wastes">Wastes</button>
                </div>
            `;
            basicLandsList.appendChild(quickAddPanel);

            // Add event listeners for quick-add buttons
            document.querySelectorAll('.quick-add-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const landType = this.getAttribute('data-land');
                    commanderDeck.basicLands[landType]++;
                    renderBasicLands();
                    updateCommanderDeckStats();
                });
            });

            // Add individual land controls
            Object.keys(commanderDeck.basicLands).forEach(landType => {
                const count = commanderDeck.basicLands[landType];
                const li = document.createElement('li');
                li.innerHTML = `
                    <div class="basic-land-item">
                        <span class="land-name">${landType}</span>
                        <div class="land-controls">
                            <button class="land-btn minus-btn" data-land="${landType}">-</button>
                            <span class="land-count">${count}</span>
                            <button class="land-btn plus-btn" data-land="${landType}">+</button>
                        </div>
                    </div>
                `;
                basicLandsList.appendChild(li);
            });

            // Add event listeners for land buttons
            document.querySelectorAll('.land-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const landType = this.getAttribute('data-land');
                    const isPlus = this.classList.contains('plus-btn');
                    if (isPlus) {
                        commanderDeck.basicLands[landType]++;
                    } else if (commanderDeck.basicLands[landType] > 0) {
                        commanderDeck.basicLands[landType]--;
                    }
                    renderBasicLands();
                    updateCommanderDeckStats();
                });
            });
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Hide card pool sections initially
            const rarityGroups = document.querySelectorAll('#card-pool .card-pool-group');
            rarityGroups.forEach(group => {
                group.style.display = 'none';
            });

            fetchCardSets();
            updateCacheStatus(); // Initialize cache status

            // Set selection change
            document.getElementById('set-select').addEventListener('change', updateBoosterTypes);

            // Booster type selection change
            document.getElementById('booster-type').addEventListener('change', updateBoxSize);

            // Clear cache button
            document.getElementById('clear-cache').addEventListener('click', function() {
                scryfallAPI.clearCache();
                updateCacheStatus();
                alert('Cache cleared!');
            });

            // Open booster button
            document.getElementById('open-booster').addEventListener('click', function() {
                // If deck is not empty, prompt for confirmation
                if (commanderDeck.commander || (commanderDeck.cards && commanderDeck.cards.length > 0)) {
                    if (!confirm('You have a Commander Deck in progress. Are you sure you want to open a new box and reset your deck?')) {
                        return;
                    }
                }
                // Reset commander deck
                commanderDeck.commander = null;
                commanderDeck.cards = [];
                commanderDeck.basicLands = {
                    Plains: 0,
                    Island: 0,
                    Swamp: 0,
                    Mountain: 0,
                    Forest: 0,
                    Wastes: 0
                };
                renderCommanderDeck();

                const setSelect = document.getElementById('set-select');
                const boosterTypeSelect = document.getElementById('booster-type');
                const boxSizeInput = document.getElementById('box-size');

                if (!setSelect.value || !boosterTypeSelect.value) {
                    alert('Please select a set and booster type.');
                    return;
                }

                const boxSize = parseInt(boxSizeInput.value);
                if (!boxSizeInput.value || isNaN(boxSize) || boxSize < 1) {
                    alert('Please enter a valid box size (positive integer).');
                    return;
                }

                console.log('Opening booster:', {
                    set: selectedSet.name,
                    boosterType: boosterTypeSelect.value,
                    boxSize: boxSize,
                    setData: setData,
                    bonusSheetData: bonusSheetData
                });

                // Simulate opening packs and display results
                const boosterDisplay = document.getElementById('booster-display');
                let output = '';

                // Card pool aggregation
                cardPool = {
                    mythic: {},
                    rare: {},
                    uncommon: {},
                    common: {}
                };
                // Store full card data for reference
                cardDataMap = {};

                // Helper: pick an item based on probability weights
                function pickWeighted(items) {
                    const total = items.reduce((sum, item) => sum + item.probability, 0);
                    let r = Math.random() * total;
                    for (const item of items) {
                        if (r < item.probability) return item;
                        r -= item.probability;
                    }
                    return items[items.length - 1]; // fallback
                }

                // Helper: get all cards from a set by rarity and collector number
                function getCardsFromSet(setCode, rarity, collectorNumbers, collectorNumberRanges, exclusions) {
                    let cardPool = [];
                    let cardData = null;
                    if (setData && setData.setCode === setCode) cardData = setData.cards;
                    else if (bonusSheetData && bonusSheetData.setCode === setCode) cardData = bonusSheetData.cards;
                    if (!cardData) return [];

                    // Filter by rarity
                    cardPool = cardData.filter(card => {
                        // Skip empty card objects (from the array structure)
                        if (!card || !card.name) return false;

                        if (Array.isArray(rarity)) {
                            if (!rarity.includes(card.rarity)) return false;
                        } else if (rarity && card.rarity !== rarity) {
                            return false;
                        }
                        return true;
                    });

                    // Filter by collectorNumbers
                    if (collectorNumbers) {
                        cardPool = cardPool.filter(card => collectorNumbers.includes(card.collectorNumber));
                    }

                    // Filter by collectorNumberRanges
                    if (collectorNumberRanges) {
                        let validNumbers = new Set();
                        collectorNumberRanges.forEach(range => {
                            for (let n = range.start; n <= range.end; n++) validNumbers.add(n);
                        });
                        cardPool = cardPool.filter(card => validNumbers.has(card.collectorNumber));
                    }

                    // Exclude exclusions
                    if (exclusions) {
                        cardPool = cardPool.filter(card => !exclusions.includes(card.collectorNumber));
                    }

                    return cardPool;
                }

                // Main simulation
                const boosterType = boosterTypeSelect.value;
                const boosterConfig = selectedSet.boosterTypes[boosterType.charAt(0).toUpperCase() + boosterType.slice(1)];
                const slots = boosterConfig.slots;

                for (let i = 0; i < boxSize; i++) {
                    let slotResults = '';
                    slots.forEach((slot, slotIdx) => {
                        let cardName = '(no card found)';
                        let cardRarity = null;
                        let attempts = 0;
                        let card = null;
                        while (attempts < 10) {
                            const pickedItem = pickWeighted(slot.items);
                            // Get card pool for this item
                            const cards = getCardsFromSet(
                                pickedItem.set,
                                pickedItem.rarity || pickedItem.rarities || slot.rarity,
                                pickedItem.collectorNumbers,
                                pickedItem.collectorNumberRanges || pickedItem.collectorNumberRange,
                                pickedItem.exclusions
                            );
                            if (cards.length > 0) {
                                card = cards[Math.floor(Math.random() * cards.length)];
                                cardName = card.name + (card.rarity ? ` [${card.rarity}]` : '');
                                cardRarity = card.rarity ? card.rarity.toLowerCase() : null;
                                break;
                            }
                            attempts++;
                        }
                        // Aggregate card pool by rarity
                        if (card && cardRarity) {
                            let rarityKey = cardRarity;
                            if (rarityKey === 'mythic') rarityKey = 'mythic';
                            if (rarityKey === 'rare') rarityKey = 'rare';
                            if (rarityKey === 'uncommon') rarityKey = 'uncommon';
                            if (rarityKey === 'common') rarityKey = 'common';
                            if (cardPool[rarityKey]) {
                                if (!cardPool[rarityKey][card.name]) {
                                    cardPool[rarityKey][card.name] = 1;
                                    // Store full card data for reference
                                    cardDataMap[card.name] = card;
                                } else {
                                    cardPool[rarityKey][card.name]++;
                                }
                            }
                        }
                        let cardImageHtml = '';
                        if (card && card.imageUris) {
                            if (card.imageUris.normal) {
                                cardImageHtml = `<div class="card-image-container"><img src="${card.imageUris.normal}" alt="${card.name}" class="card-thumbnail" loading="lazy"></div>`;
                            } else if (card.imageUris.small) {
                                cardImageHtml = `<div class="card-image-container"><img src="${card.imageUris.small}" alt="${card.name}" class="card-thumbnail" loading="lazy"></div>`;
                            }
                        }
                        if (!cardImageHtml && card) {
                            cardImageHtml = `<div class='card-fallback-text'><strong>${card.name}</strong><br><span>${card.typeLine||''}</span></div>`;
                        }
                        slotResults += `
                            <details class="booster-panel">
                                <summary>Slot ${slotIdx + 1}: ${slot.name}</summary>
                                <div>${cardImageHtml}</div>
                            </details>
                        `;
                    });
                    output += `
                        <details class="booster-panel">
                            <summary>Booster ${i + 1}</summary>
                            <div>${slotResults}</div>
                        </details>
                    `;
                }

                // Render card pool
                renderCardPool();

                boosterDisplay.innerHTML = output;

                // --- Dynamically create Expand/Collapse All Button ---
                const detailsList = boosterDisplay.querySelectorAll('details');
                let toggleAllBtn = document.getElementById('toggle-all-boosters');
                if (toggleAllBtn) toggleAllBtn.remove(); // Remove any previous button
                if (detailsList.length > 0) {
                    toggleAllBtn = document.createElement('button');
                    toggleAllBtn.id = 'toggle-all-boosters';
                    toggleAllBtn.className = 'secondary-button';
                    toggleAllBtn.style.marginBottom = '1em';
                    toggleAllBtn.textContent = 'Expand All';
                    let expanded = false;
                    toggleAllBtn.onclick = function() {
                        expanded = !expanded;
                        detailsList.forEach(d => d.open = expanded);
                        toggleAllBtn.textContent = expanded ? 'Collapse All' : 'Expand All';
                    };
                    boosterDisplay.prepend(toggleAllBtn);
                }

                // After renderCardPool is called, also render the commander deck
                renderCommanderDeck();
            });
        });
    </script>
</body>
</html>